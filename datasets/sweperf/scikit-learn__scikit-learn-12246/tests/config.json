{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-12246",
  "patch": "diff --git a/doc/whats_new/v0.20.rst b/doc/whats_new/v0.20.rst\nindex 2c4ef814a0a31..d53983419533e 100644\n--- a/doc/whats_new/v0.20.rst\n+++ b/doc/whats_new/v0.20.rst\n@@ -37,6 +37,9 @@ Changelog\n :mod:`sklearn.datasets`\n ............................\n \n+- |Fix| :func:`dataset.fetch_openml` to correctly use the local cache.\n+  :issue:`12246` by :user:`Jan N. van Rijn <janvanrijn>`.\n+\n - |Fix| Fixed integer overflow in :func:`datasets.make_classification`\n   for values of ``n_informative`` parameter larger than 64.\n   :issue:10811 by :user:`Roman Feldbauer <VarIr>`.\ndiff --git a/sklearn/datasets/openml.py b/sklearn/datasets/openml.py\nindex d667cb3699b28..5820ff68c0925 100644\n--- a/sklearn/datasets/openml.py\n+++ b/sklearn/datasets/openml.py\n@@ -31,6 +31,10 @@\n _DATA_FILE = \"data/v1/download/{}\"\n \n \n+def _get_local_path(openml_path, data_home):\n+    return os.path.join(data_home, 'openml.org', openml_path + \".gz\")\n+\n+\n def _open_openml_url(openml_path, data_home):\n     \"\"\"\n     Returns a resource from OpenML.org. Caches it to data_home if required.\n@@ -50,20 +54,23 @@ def _open_openml_url(openml_path, data_home):\n     result : stream\n         A stream to the OpenML resource\n     \"\"\"\n+    def is_gzip(_fsrc):\n+        return _fsrc.info().get('Content-Encoding', '') == 'gzip'\n+\n     req = Request(_OPENML_PREFIX + openml_path)\n     req.add_header('Accept-encoding', 'gzip')\n-    fsrc = urlopen(req)\n-    is_gzip = fsrc.info().get('Content-Encoding', '') == 'gzip'\n \n     if data_home is None:\n-        if is_gzip:\n+        fsrc = urlopen(req)\n+        if is_gzip(fsrc):\n             if PY2:\n                 fsrc = BytesIO(fsrc.read())\n             return gzip.GzipFile(fileobj=fsrc, mode='rb')\n         return fsrc\n \n-    local_path = os.path.join(data_home, 'openml.org', openml_path + \".gz\")\n+    local_path = _get_local_path(openml_path, data_home)\n     if not os.path.exists(local_path):\n+        fsrc = urlopen(req)\n         try:\n             os.makedirs(os.path.dirname(local_path))\n         except OSError:\n@@ -71,16 +78,21 @@ def _open_openml_url(openml_path, data_home):\n             pass\n \n         try:\n-            with open(local_path, 'wb') as fdst:\n-                shutil.copyfileobj(fsrc, fdst)\n-                fsrc.close()\n+            if is_gzip(fsrc):\n+                with open(local_path, 'wb') as fdst:\n+                    shutil.copyfileobj(fsrc, fdst)\n+                    fsrc.close()\n+            else:\n+                with gzip.GzipFile(local_path, 'wb') as fdst:\n+                    shutil.copyfileobj(fsrc, fdst)\n+                    fsrc.close()\n         except Exception:\n             os.unlink(local_path)\n             raise\n-    # XXX: unnecessary decompression on first access\n-    if is_gzip:\n-        return gzip.GzipFile(local_path, 'rb')\n-    return fsrc\n+\n+    # XXX: First time, decompression will not be necessary (by using fsrc), but\n+    # it will happen nonetheless\n+    return gzip.GzipFile(local_path, 'rb')\n \n \n def _get_json_content_from_openml_api(url, error_message, raise_if_error,\n",
  "test_patch": "diff --git a/sklearn/datasets/tests/test_openml.py b/sklearn/datasets/tests/test_openml.py\nindex cf9cfcdc81ede..7a317f2f3799b 100644\n--- a/sklearn/datasets/tests/test_openml.py\n+++ b/sklearn/datasets/tests/test_openml.py\n@@ -12,7 +12,8 @@\n from sklearn.datasets import fetch_openml\n from sklearn.datasets.openml import (_open_openml_url,\n                                      _get_data_description_by_id,\n-                                     _download_data_arff)\n+                                     _download_data_arff,\n+                                     _get_local_path)\n from sklearn.utils.testing import (assert_warns_message,\n                                    assert_raise_message)\n from sklearn.externals.six import string_types\n@@ -77,6 +78,8 @@ def _fetch_dataset_from_openml(data_id, data_name, data_version,\n                                    cache=False)\n     assert int(data_by_name_id.details['id']) == data_id\n \n+    # Please note that cache=False is crucial, as the monkey patched files are\n+    # not consistent with reality\n     fetch_openml(name=data_name, cache=False)\n     # without specifying the version, there is no guarantee that the data id\n     # will be the same\n@@ -138,6 +141,9 @@ def _fetch_dataset_from_openml(data_id, data_name, data_version,\n def _monkey_patch_webbased_functions(context,\n                                      data_id,\n                                      gzip_response):\n+    # monkey patches the urlopen function. Important note: Do NOT use this\n+    # in combination with a regular cache directory, as the files that are\n+    # stored as cache should not be mixed up with real openml datasets\n     url_prefix_data_description = \"https://openml.org/api/v1/json/data/\"\n     url_prefix_data_features = \"https://openml.org/api/v1/json/data/features/\"\n     url_prefix_download_data = \"https://openml.org/data/v1/\"\n@@ -453,23 +459,47 @@ def test_decode_emotions(monkeypatch):\n \n \n @pytest.mark.parametrize('gzip_response', [True, False])\n-def test_open_openml_url_cache(monkeypatch, gzip_response):\n+def test_open_openml_url_cache(monkeypatch, gzip_response, tmpdir):\n     data_id = 61\n \n     _monkey_patch_webbased_functions(\n         monkeypatch, data_id, gzip_response)\n     openml_path = sklearn.datasets.openml._DATA_FILE.format(data_id)\n-    test_directory = os.path.join(os.path.expanduser('~'), 'scikit_learn_data')\n+    cache_directory = str(tmpdir.mkdir('scikit_learn_data'))\n     # first fill the cache\n-    response1 = _open_openml_url(openml_path, test_directory)\n+    response1 = _open_openml_url(openml_path, cache_directory)\n     # assert file exists\n-    location = os.path.join(test_directory, 'openml.org', openml_path + '.gz')\n+    location = _get_local_path(openml_path, cache_directory)\n     assert os.path.isfile(location)\n     # redownload, to utilize cache\n-    response2 = _open_openml_url(openml_path, test_directory)\n+    response2 = _open_openml_url(openml_path, cache_directory)\n     assert response1.read() == response2.read()\n \n \n+@pytest.mark.parametrize('gzip_response', [True, False])\n+def test_fetch_openml_cache(monkeypatch, gzip_response, tmpdir):\n+    def _mock_urlopen_raise(request):\n+        raise ValueError('This mechanism intends to test correct cache'\n+                         'handling. As such, urlopen should never be '\n+                         'accessed. URL: %s' % request.get_full_url())\n+    data_id = 2\n+    cache_directory = str(tmpdir.mkdir('scikit_learn_data'))\n+    _monkey_patch_webbased_functions(\n+        monkeypatch, data_id, gzip_response)\n+    X_fetched, y_fetched = fetch_openml(data_id=data_id, cache=True,\n+                                        data_home=cache_directory,\n+                                        return_X_y=True)\n+\n+    monkeypatch.setattr(sklearn.datasets.openml, 'urlopen',\n+                        _mock_urlopen_raise)\n+\n+    X_cached, y_cached = fetch_openml(data_id=data_id, cache=True,\n+                                      data_home=cache_directory,\n+                                      return_X_y=True)\n+    np.testing.assert_array_equal(X_fetched, X_cached)\n+    np.testing.assert_array_equal(y_fetched, y_cached)\n+\n+\n @pytest.mark.parametrize('gzip_response', [True, False])\n def test_fetch_openml_notarget(monkeypatch, gzip_response):\n     data_id = 61\n",
  "base_commit": "877e3f3235dc5caa86838ef87df75a31e08649c4",
  "head_commit": "301857abe7428ae3b75bd76ab27bc27269860673",
  "created_at": 1538487070000,
  "version": "0.21",
  "duration_changes": "[{\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.14138473197817802, \"head\": 0.07520917803049088}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.01814379170536995, \"head\": 0.018021218478679657}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.020084131509065628, \"head\": 0.015197612345218658}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.0020871758460998535, \"head\": 0.0021392740309238434}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.058117497712373734, \"head\": 0.011515125632286072}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.13052890077233315, \"head\": 0.0475638248026371}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.007376130670309067, \"head\": 0.01804659143090248}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.012057073414325714, \"head\": 0.015298832207918167}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.0047265589237213135, \"head\": 0.08335725590586662}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.05560510605573654, \"head\": 0.1012185700237751}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.10693049430847168, \"head\": 0.13641071692109108}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.040872689336538315, \"head\": 0.06493156403303146}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.017453763633966446, \"head\": 0.013406224548816681}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.009641546756029129, \"head\": 0.014287438243627548}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.03743685781955719, \"head\": 0.04821079224348068}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.07162613794207573, \"head\": 0.02942105010151863}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.0608634427189827, \"head\": 0.007314957678318024}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.015924900770187378, \"head\": 0.01210721954703331}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.010205443948507309, \"head\": 0.0020427145063877106}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.06884234771132469, \"head\": 0.011257901787757874}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.03601834923028946, \"head\": 0.152605339884758}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.010233476758003235, \"head\": 0.007288455963134766}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.01254240795969963, \"head\": 0.012088164687156677}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.07439711689949036, \"head\": 0.010895662009716034}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.02293827384710312, \"head\": 0.015736926347017288}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.1823243424296379, \"head\": 0.1449974738061428}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.008032765239477158, \"head\": 0.007241014391183853}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.01199326291680336, \"head\": 0.01205281913280487}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.00972321629524231, \"head\": 0.050963446497917175}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.01433400809764862, \"head\": 0.014960534870624542}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.036827608942985535, \"head\": 0.1648440696299076}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.010899618268013, \"head\": 0.012408357113599777}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.01516428217291832, \"head\": 0.011910051107406616}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.011562265455722809, \"head\": 0.002110719680786133}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.07276168093085289, \"head\": 0.022915024310350418}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.15852872282266617, \"head\": 0.03482326865196228}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.013510115444660187, \"head\": 0.05650917440652847}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.012473538517951965, \"head\": 0.09357291832566261}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.0384962260723114, \"head\": 0.011003583669662476}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.08993874490261078, \"head\": 0.013474743813276291}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.03140942007303238, \"head\": 0.16581866890192032}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.007514737546443939, \"head\": 0.007626064121723175}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.0827253982424736, \"head\": 0.01656971126794815}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.005639463663101196, \"head\": 0.02068391814827919}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.01613251119852066, \"head\": 0.034090861678123474}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.1283959411084652, \"head\": 0.18143290653824806}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.007343269884586334, \"head\": 0.007264330983161926}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.012275956571102142, \"head\": 0.0119866244494915}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.07444945722818375, \"head\": 0.024055730551481247}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.08468664810061455, \"head\": 0.04505075514316559}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.15048013627529144, \"head\": 0.22735129669308662}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.007460057735443115, \"head\": 0.01662473753094673}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.012429144233465195, \"head\": 0.012005075812339783}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.014160972088575363, \"head\": 0.001828208565711975}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.03824041411280632, \"head\": 0.014071810990571976}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.20280568301677704, \"head\": 0.1928073987364769}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.006999451667070389, \"head\": 0.00767802819609642}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.011863552033901215, \"head\": 0.012360334396362305}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.009724274277687073, \"head\": 0.0060775987803936005}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.014778293669223785, \"head\": 0.012381084263324738}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.06769650429487228, \"head\": 0.031160887330770493}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.06431086733937263, \"head\": 0.007227826863527298}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.016703113913536072, \"head\": 0.012239117175340652}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.04927833750844002, \"head\": 0.0022563114762306213}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.1061100997030735, \"head\": 0.030559033155441284}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.16084976494312286, \"head\": 0.06973156332969666}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.010374639183282852, \"head\": 0.008152719587087631}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.012361697852611542, \"head\": 0.0921519510447979}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.017036139965057373, \"head\": 0.002215750515460968}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.014155782759189606, \"head\": 0.014676690101623535}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.06521163508296013, \"head\": 0.16296415030956268}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.060057979077100754, \"head\": 0.007326256483793259}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.012331631034612656, \"head\": 0.011835888028144836}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.0018660128116607666, \"head\": 0.009718697518110275}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.014807257801294327, \"head\": 0.012724913656711578}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.1483537144958973, \"head\": 0.17081335559487343}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.007583387196063995, \"head\": 0.008532974869012833}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.012443941086530685, \"head\": 0.012622106820344925}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.001761309802532196, \"head\": 0.014978181570768356}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.011513102799654007, \"head\": 0.013065293431282043}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.06915726140141487, \"head\": 0.10509884729981422}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.08210233971476555, \"head\": 0.014888793230056763}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.013220574706792831, \"head\": 0.012051776051521301}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.025422975420951843, \"head\": 0.04853716865181923}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.07180266454815865, \"head\": 0.0372743122279644}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.14041880145668983, \"head\": 0.1618141084909439}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.008109882473945618, \"head\": 0.009876389056444168}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.012134823948144913, \"head\": 0.012127861380577087}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.05151459947228432, \"head\": 0.047662802040576935}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.024665668606758118, \"head\": 0.0959872305393219}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.043670281767845154, \"head\": 0.12657802924513817}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.03934849426150322, \"head\": 0.016313936561346054}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.08139124140143394, \"head\": 0.016812726855278015}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.004232160747051239, \"head\": 0.07463893294334412}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.022531665861606598, \"head\": 0.08715029805898666}}, {\"sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict\": {\"base\": 0.054827794432640076, \"head\": 0.1817215122282505}, \"sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]\": {\"base\": 0.010359745472669601, \"head\": 0.010370064526796341}, \"sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]\": {\"base\": 0.08651907742023468, \"head\": 0.014212153851985931}, \"sklearn/tests/test_kernel_ridge.py::test_kernel_ridge\": {\"base\": 0.0073199160397052765, \"head\": 0.007527399808168411}, \"sklearn/tests/test_multiclass.py::test_ovo_fit_on_list\": {\"base\": 0.014501336961984634, \"head\": 0.014475155621767044}}]",
  "efficiency_test": [
    "sklearn/mixture/tests/test_gaussian_mixture.py::test_gaussian_mixture_fit_predict",
    "sklearn/tests/test_common.py::test_non_meta_estimators[FactorAnalysis-FactorAnalysis-check_transformers_unfitted]",
    "sklearn/tests/test_common.py::test_non_meta_estimators[GaussianProcessClassifier-GaussianProcessClassifier-check_estimators_overwrite_params]",
    "sklearn/tests/test_kernel_ridge.py::test_kernel_ridge",
    "sklearn/tests/test_multiclass.py::test_ovo_fit_on_list"
  ],
  "patch_functions": "{\"sklearn/datasets/openml.py\": [\"_open_openml_url\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'sklearn/datasets/openml.py': ['_open_openml_url']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"sklearn/mixture/gaussian_mixture.py\": [\"GaussianMixture\"], \"sklearn/multiclass.py\": [\"OneVsOneClassifier\", \"OneVsOneClassifier.fit\", \"OneVsOneClassifier.predict\"], \"sklearn/linear_model/base.py\": [\"Ridge.predict\", \"LinearSVC.predict\"], \"sklearn/utils/estimator_checks.py\": [\"_yield_all_checks\", \"set_checking_parameters\"], \"sklearn/utils/deprecation.py\": [\"wrapped\"], \"sklearn/svm/classes.py\": [\"LinearSVC\", \"LinearSVC.fit\"], \"sklearn/kernel_ridge.py\": [\"KernelRidge.predict\", \"KernelRidge\", \"KernelRidge.fit\"], \"sklearn/metrics/cluster/supervised.py\": [\"adjusted_rand_score\"], \"sklearn/datasets/base.py\": [\"load_iris\"], \"sklearn/mixture/base.py\": [\"GaussianMixture.predict\", \"GaussianMixture.fit\", \"GaussianMixture.fit_predict\"], \"sklearn/linear_model/ridge.py\": [\"Ridge\", \"Ridge.fit\"], \"sklearn/datasets/samples_generator.py\": [\"make_regression\", \"make_spd_matrix\"], \"sklearn/base.py\": [\"AdaBoostClassifier.get_params\"], \"sklearn/cluster/k_means_.py\": [\"KMeans.fit\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'sklearn/mixture/gaussian_mixture.py': ['GaussianMixture'], 'sklearn/multiclass.py': ['OneVsOneClassifier', 'OneVsOneClassifier.fit', 'OneVsOneClassifier.predict'], 'sklearn/linear_model/base.py': ['Ridge.predict', 'LinearSVC.predict'], 'sklearn/utils/estimator_checks.py': ['_yield_all_checks', 'set_checking_parameters'], 'sklearn/utils/deprecation.py': ['wrapped'], 'sklearn/svm/classes.py': ['LinearSVC', 'LinearSVC.fit'], 'sklearn/kernel_ridge.py': ['KernelRidge.predict', 'KernelRidge', 'KernelRidge.fit'], 'sklearn/metrics/cluster/supervised.py': ['adjusted_rand_score'], 'sklearn/datasets/base.py': ['load_iris'], 'sklearn/mixture/base.py': ['GaussianMixture.predict', 'GaussianMixture.fit', 'GaussianMixture.fit_predict'], 'sklearn/linear_model/ridge.py': ['Ridge', 'Ridge.fit'], 'sklearn/datasets/samples_generator.py': ['make_regression', 'make_spd_matrix'], 'sklearn/base.py': ['AdaBoostClassifier.get_params'], 'sklearn/cluster/k_means_.py': ['KMeans.fit']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.02920000000000002
}