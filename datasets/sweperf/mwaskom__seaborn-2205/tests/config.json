{
  "repo": "mwaskom/seaborn",
  "instance_id": "mwaskom__seaborn-2205",
  "patch": "diff --git a/seaborn/_core.py b/seaborn/_core.py\nindex 9c59ab0450..0bf7b3ff7b 100644\n--- a/seaborn/_core.py\n+++ b/seaborn/_core.py\n@@ -708,10 +708,15 @@ def _assign_variables_wideform(self, data=None, **kwargs):\n             the inputs (or None when no name can be determined).\n \n         \"\"\"\n-        # TODO raise here if any kwarg values are not None,\n-        # # if we decide for \"structure-only\" wide API\n+        # Raise if semantic or other variables are assigned in wide-form mode\n+        assigned = [k for k, v in kwargs.items() if v is not None]\n+        if any(assigned):\n+            s = \"s\" if len(assigned) > 1 else \"\"\n+            err = f\"The following variable{s} cannot be assigned with wide-form data: \"\n+            err += \", \".join(f\"`{v}`\" for v in assigned)\n+            raise ValueError(err)\n \n-        # First, determine if the data object actually has any data in it\n+        # Determine if the data object actually has any data in it\n         empty = data is None or not len(data)\n \n         # Then, determine if we have \"flat\" data (a single vector)\n@@ -884,14 +889,26 @@ def _assign_variables_longform(self, data=None, **kwargs):\n                     variables[key] = val\n                 else:\n                     # We don't know what this name means\n-                    err = f\"Could not interpret input '{val}'\"\n+                    err = f\"Could not interpret value `{val}` for parameter `{key}`\"\n                     raise ValueError(err)\n \n             else:\n \n                 # Otherwise, assume the value is itself a vector of data\n-                # TODO check for 1D here or let pd.DataFrame raise?\n+\n+                # Raise when data is present and a vector can't be combined with it\n+                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):\n+                    if val is not None and len(data) != len(val):\n+                        val_cls = val.__class__.__name__\n+                        err = (\n+                            f\"Length of {val_cls} vectors must match length of `data`\"\n+                            f\" when both are used, but `data` has length {len(data)}\"\n+                            f\" and the vector passed to `{key}` has length {len(val)}.\"\n+                        )\n+                        raise ValueError(err)\n+\n                 plot_data[key] = val\n+\n                 # Try to infer the name of the variable\n                 variables[key] = getattr(val, \"name\", None)\n \ndiff --git a/seaborn/categorical.py b/seaborn/categorical.py\nindex 34aa383da8..70a7525dbf 100644\n--- a/seaborn/categorical.py\n+++ b/seaborn/categorical.py\n@@ -45,7 +45,7 @@ def establish_variables(self, x=None, y=None, hue=None, data=None,\n \n             # Do a sanity check on the inputs\n             if hue is not None:\n-                error = \"Cannot use `hue` without `x` or `y`\"\n+                error = \"Cannot use `hue` without `x` and `y`\"\n                 raise ValueError(error)\n \n             # No hue grouping with wide inputs\n",
  "test_patch": "diff --git a/seaborn/conftest.py b/seaborn/conftest.py\nindex 2630971da5..f4809c7cc8 100644\n--- a/seaborn/conftest.py\n+++ b/seaborn/conftest.py\n@@ -197,6 +197,6 @@ def missing_df(rng, long_df):\n \n \n @pytest.fixture\n-def null_series():\n+def null_series(flat_series):\n \n-    return pd.Series(index=np.arange(20), dtype='float64')\n+    return pd.Series(index=flat_series.index, dtype='float64')\ndiff --git a/seaborn/tests/test_core.py b/seaborn/tests/test_core.py\nindex 1215847069..ac1c90fac7 100644\n--- a/seaborn/tests/test_core.py\n+++ b/seaborn/tests/test_core.py\n@@ -78,9 +78,9 @@ def test_plotter_reinit(self, long_df):\n         assert p._hue_map.palette == palette\n         assert p._hue_map.levels == hue_order\n \n-    def test_hue_map_null(self, long_df, null_series):\n+    def test_hue_map_null(self, flat_series, null_series):\n \n-        p = VectorPlotter(variables=dict(hue=null_series))\n+        p = VectorPlotter(variables=dict(x=flat_series, hue=null_series))\n         m = HueMapping(p)\n         assert m.levels is None\n         assert m.map_type is None\n@@ -341,9 +341,9 @@ def test_plotter_reinit(self, long_df):\n         assert p._size_map.lookup_table == dict(zip(size_order, sizes))\n         assert p._size_map.levels == size_order\n \n-    def test_size_map_null(self, long_df, null_series):\n+    def test_size_map_null(self, flat_series, null_series):\n \n-        p = VectorPlotter(variables=dict(size=null_series))\n+        p = VectorPlotter(variables=dict(x=flat_series, size=null_series))\n         m = HueMapping(p)\n         assert m.levels is None\n         assert m.map_type is None\n@@ -482,9 +482,9 @@ def test_plotter_reinit(self, long_df):\n         assert p._style_map.levels == style_order\n         assert p._style_map(style_order, \"marker\") == markers\n \n-    def test_style_map_null(self, long_df, null_series):\n+    def test_style_map_null(self, flat_series, null_series):\n \n-        p = VectorPlotter(variables=dict(style=null_series))\n+        p = VectorPlotter(variables=dict(x=flat_series, style=null_series))\n         m = HueMapping(p)\n         assert m.levels is None\n         assert m.map_type is None\n@@ -596,9 +596,27 @@ def test_flat_variables(self, flat_data):\n         assert p.variables[\"x\"] == expected_x_name\n         assert p.variables[\"y\"] == expected_y_name\n \n-    # TODO note that most of the other tests that excercise the core\n+    # TODO note that most of the other tests that exercise the core\n     # variable assignment code still live in test_relational\n \n+    def test_wide_semantic_error(self, wide_df):\n+\n+        err = \"The following variable cannot be assigned with wide-form data: `hue`\"\n+        with pytest.raises(ValueError, match=err):\n+            VectorPlotter(data=wide_df, variables={\"hue\": \"a\"})\n+\n+    def test_long_unknown_error(self, long_df):\n+\n+        err = \"Could not interpret value `what` for parameter `hue`\"\n+        with pytest.raises(ValueError, match=err):\n+            VectorPlotter(data=long_df, variables={\"x\": \"x\", \"hue\": \"what\"})\n+\n+    def test_long_unmatched_size_error(self, long_df, flat_array):\n+\n+        err = \"Length of ndarray vectors must match length of `data`\"\n+        with pytest.raises(ValueError, match=err):\n+            VectorPlotter(data=long_df, variables={\"x\": \"x\", \"hue\": flat_array})\n+\n     def test_wide_categorical_columns(self, wide_df):\n \n         wide_df.columns = pd.CategoricalIndex(wide_df.columns)\ndiff --git a/seaborn/tests/test_distributions.py b/seaborn/tests/test_distributions.py\nindex 2e475f2c2a..19efc5c9c8 100644\n--- a/seaborn/tests/test_distributions.py\n+++ b/seaborn/tests/test_distributions.py\n@@ -2018,9 +2018,10 @@ def test_versus_single_histplot(self, long_df, kwargs):\n         if ax.legend_ is not None:\n             self.assert_legends_equal(ax.legend_, g._legend)\n \n-        long_df[\"_\"] = \"_\"\n-        g2 = displot(long_df, col=\"_\", **kwargs)\n-        self.assert_plots_equal(ax, g2.ax)\n+        if kwargs:\n+            long_df[\"_\"] = \"_\"\n+            g2 = displot(long_df, col=\"_\", **kwargs)\n+            self.assert_plots_equal(ax, g2.ax)\n \n     @pytest.mark.parametrize(\n         \"kwargs\", [\n@@ -2050,9 +2051,10 @@ def test_versus_single_kdeplot(self, long_df, kwargs):\n         if ax.legend_ is not None:\n             self.assert_legends_equal(ax.legend_, g._legend)\n \n-        long_df[\"_\"] = \"_\"\n-        g2 = displot(long_df, kind=\"kde\", col=\"_\", **kwargs)\n-        self.assert_plots_equal(ax, g2.ax)\n+        if kwargs:\n+            long_df[\"_\"] = \"_\"\n+            g2 = displot(long_df, kind=\"kde\", col=\"_\", **kwargs)\n+            self.assert_plots_equal(ax, g2.ax)\n \n     @pytest.mark.parametrize(\n         \"kwargs\", [\n@@ -2077,9 +2079,10 @@ def test_versus_single_ecdfplot(self, long_df, kwargs):\n         if ax.legend_ is not None:\n             self.assert_legends_equal(ax.legend_, g._legend)\n \n-        long_df[\"_\"] = \"_\"\n-        g2 = displot(long_df, kind=\"ecdf\", col=\"_\", **kwargs)\n-        self.assert_plots_equal(ax, g2.ax)\n+        if kwargs:\n+            long_df[\"_\"] = \"_\"\n+            g2 = displot(long_df, kind=\"ecdf\", col=\"_\", **kwargs)\n+            self.assert_plots_equal(ax, g2.ax)\n \n     @pytest.mark.parametrize(\n         \"kwargs\", [\n",
  "base_commit": "9d96d8f66c2171080794efdb591774cf05c6aa5e",
  "head_commit": "5b4d3f51288ff0b583e5be54b9ca9f92ca0ea3b9",
  "created_at": 1597792013000,
  "version": "0.11",
  "duration_changes": "[{\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05487551912665367, \"head\": 0.055234432220458984}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05653664842247963, \"head\": 0.059331174939870834}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05423080921173096, \"head\": 0.056837499141693115}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.07339487224817276, \"head\": 0.05620491877198219}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05528870224952698, \"head\": 0.05815558508038521}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.06366225704550743, \"head\": 0.0560385026037693}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05959204584360123, \"head\": 0.05359814316034317}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.06455905735492706, \"head\": 0.06109834089875221}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05765039846301079, \"head\": 0.057588376104831696}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.06508708000183105, \"head\": 0.06254535168409348}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.059326499700546265, \"head\": 0.053251221776008606}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05664258077740669, \"head\": 0.05538081005215645}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.08046597987413406, \"head\": 0.05738029628992081}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05938855558633804, \"head\": 0.05788237228989601}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05370156094431877, \"head\": 0.057882823050022125}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.0682448148727417, \"head\": 0.055737659335136414}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05937715247273445, \"head\": 0.05822952464222908}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.06328227743506432, \"head\": 0.05521762743592262}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.05583523213863373, \"head\": 0.06033289059996605}}, {\"seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data\": {\"base\": 0.06141406297683716, \"head\": 0.05735988914966583}}]",
  "efficiency_test": [
    "seaborn/tests/test_distributions.py::TestRugPlot::test_rug_data"
  ],
  "patch_functions": "{\"seaborn/_core.py\": [\"VectorPlotter._assign_variables_longform\", \"VectorPlotter._assign_variables_wideform\"], \"seaborn/categorical.py\": [\"_CategoricalPlotter.establish_variables\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'seaborn/_core.py': ['VectorPlotter._assign_variables_longform', 'VectorPlotter._assign_variables_wideform'], 'seaborn/categorical.py': ['_CategoricalPlotter.establish_variables']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"seaborn/_decorators.py\": [\"inner_f\"], \"seaborn/distributions.py\": [\"rugplot\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'seaborn/_decorators.py': ['inner_f'], 'seaborn/distributions.py': ['rugplot']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.010000000000000002
}