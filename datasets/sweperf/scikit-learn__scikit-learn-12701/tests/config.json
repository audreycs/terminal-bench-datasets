{
  "repo": "scikit-learn/scikit-learn",
  "instance_id": "scikit-learn__scikit-learn-12701",
  "patch": "diff --git a/doc/whats_new/v0.20.rst b/doc/whats_new/v0.20.rst\nindex 94d956bb524a9..9f44e127d46f5 100644\n--- a/doc/whats_new/v0.20.rst\n+++ b/doc/whats_new/v0.20.rst\n@@ -46,6 +46,16 @@ Changelog\n   data, which raised an error in 0.20.0, now returns the expected output again.\n   :issue:`12699` by `Joris Van den Bossche`_.\n \n+:mod:`sklearn.metrics`\n+......................\n+\n+- |Fix| Fixed a bug in :func:`metrics.pairwise_distances` and\n+  :func:`metrics.pairwise_distances_chunked` where parameters ``V`` of\n+  ``\"seuclidean\"`` and ``VI`` of ``\"mahalanobis\"`` metrics were computed after\n+  the data was split into chunks instead of being pre-computed on whole data.\n+  :issue:`12701` by :user:`Jeremie du Boisberranger <jeremiedbb>`.\n+\n+\n .. _changes_0_20_1:\n \n Version 0.20.1\ndiff --git a/sklearn/metrics/pairwise.py b/sklearn/metrics/pairwise.py\nindex af456ed9c90a0..57fcc9003336b 100644\n--- a/sklearn/metrics/pairwise.py\n+++ b/sklearn/metrics/pairwise.py\n@@ -1129,6 +1129,24 @@ def _check_chunk_size(reduced, chunk_size):\n                           chunk_size))\n \n \n+def _precompute_metric_params(X, Y, metric=None, **kwds):\n+    \"\"\"Precompute data-derived metric parameters if not provided\n+    \"\"\"\n+    if metric == \"seuclidean\" and 'V' not in kwds:\n+        if X is Y:\n+            V = np.var(X, axis=0, ddof=1)\n+        else:\n+            V = np.var(np.vstack([X, Y]), axis=0, ddof=1)\n+        return {'V': V}\n+    if metric == \"mahalanobis\" and 'VI' not in kwds:\n+        if X is Y:\n+            VI = np.linalg.inv(np.cov(X.T)).T\n+        else:\n+            VI = np.linalg.inv(np.cov(np.vstack([X, Y]).T)).T\n+        return {'VI': VI}\n+    return {}\n+\n+\n def pairwise_distances_chunked(X, Y=None, reduce_func=None,\n                                metric='euclidean', n_jobs=None,\n                                working_memory=None, **kwds):\n@@ -1264,6 +1282,10 @@ def pairwise_distances_chunked(X, Y=None, reduce_func=None,\n                                         working_memory=working_memory)\n         slices = gen_batches(n_samples_X, chunk_n_rows)\n \n+    # precompute data-derived metric params\n+    params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n+    kwds.update(**params)\n+\n     for sl in slices:\n         if sl.start == 0 and sl.stop == n_samples_X:\n             X_chunk = X  # enable optimised paths for X is Y\n@@ -1395,6 +1417,10 @@ def pairwise_distances(X, Y=None, metric=\"euclidean\", n_jobs=None, **kwds):\n         dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None\n         X, Y = check_pairwise_arrays(X, Y, dtype=dtype)\n \n+        # precompute data-derived metric params\n+        params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n+        kwds.update(**params)\n+\n         if effective_n_jobs(n_jobs) == 1 and X is Y:\n             return distance.squareform(distance.pdist(X, metric=metric,\n                                                       **kwds))\n",
  "test_patch": "diff --git a/sklearn/metrics/tests/test_pairwise.py b/sklearn/metrics/tests/test_pairwise.py\nindex 5dd2d86c94545..f3c01de170b95 100644\n--- a/sklearn/metrics/tests/test_pairwise.py\n+++ b/sklearn/metrics/tests/test_pairwise.py\n@@ -5,9 +5,12 @@\n \n from scipy.sparse import dok_matrix, csr_matrix, issparse\n from scipy.spatial.distance import cosine, cityblock, minkowski, wminkowski\n+from scipy.spatial.distance import cdist, pdist, squareform\n \n import pytest\n \n+from sklearn import config_context\n+\n from sklearn.utils.testing import assert_greater\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_allclose\n@@ -893,3 +896,38 @@ def test_check_preserve_type():\n                                                    XB.astype(np.float))\n     assert_equal(XA_checked.dtype, np.float)\n     assert_equal(XB_checked.dtype, np.float)\n+\n+\n+@pytest.mark.parametrize(\"n_jobs\", [1, 2])\n+@pytest.mark.parametrize(\"metric\", [\"seuclidean\", \"mahalanobis\"])\n+@pytest.mark.parametrize(\"dist_function\",\n+                         [pairwise_distances, pairwise_distances_chunked])\n+@pytest.mark.parametrize(\"y_is_x\", [True, False], ids=[\"Y is X\", \"Y is not X\"])\n+def test_pairwise_distances_data_derived_params(n_jobs, metric, dist_function,\n+                                                y_is_x):\n+    # check that pairwise_distances give the same result in sequential and\n+    # parallel, when metric has data-derived parameters.\n+    with config_context(working_memory=0.1):  # to have more than 1 chunk\n+        rng = np.random.RandomState(0)\n+        X = rng.random_sample((1000, 10))\n+\n+        if y_is_x:\n+            Y = X\n+            expected_dist_default_params = squareform(pdist(X, metric=metric))\n+            if metric == \"seuclidean\":\n+                params = {'V': np.var(X, axis=0, ddof=1)}\n+            else:\n+                params = {'VI': np.linalg.inv(np.cov(X.T)).T}\n+        else:\n+            Y = rng.random_sample((1000, 10))\n+            expected_dist_default_params = cdist(X, Y, metric=metric)\n+            if metric == \"seuclidean\":\n+                params = {'V': np.var(np.vstack([X, Y]), axis=0, ddof=1)}\n+            else:\n+                params = {'VI': np.linalg.inv(np.cov(np.vstack([X, Y]).T)).T}\n+\n+        expected_dist_explicit_params = cdist(X, Y, metric=metric, **params)\n+        dist = np.vstack(dist_function(X, Y, metric=metric, n_jobs=n_jobs))\n+\n+        assert_allclose(dist, expected_dist_explicit_params)\n+        assert_allclose(dist, expected_dist_default_params)\n",
  "base_commit": "cd8fe168fbc2c5cfe1cb11a1cfbd7a1b7aec0acc",
  "head_commit": "aafd49a563ea90d148b1628a2acb785cebb5109a",
  "created_at": 1543589819000,
  "version": "0.21",
  "duration_changes": "[{\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8148885443806648, \"head\": 0.8350954689085484}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.0171649307012558, \"head\": 0.016832977533340454}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02347225323319435, \"head\": 0.023114260286092758}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.16556327790021896, \"head\": 0.14876090362668037}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.1916332021355629, \"head\": 0.11437497287988663}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8331024087965488, \"head\": 0.8122610114514828}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.016740843653678894, \"head\": 0.017042674124240875}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02332933247089386, \"head\": 0.03626837208867073}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.17533313482999802, \"head\": 0.3364812470972538}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.11942416802048683, \"head\": 0.014902617782354355}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8068916760385036, \"head\": 0.8235699981451035}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.016659162938594818, \"head\": 0.021291643381118774}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02643570676445961, \"head\": 0.02351389080286026}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.1841507963836193, \"head\": 0.4785756357014179}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.1179579608142376, \"head\": 0.014840509742498398}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8178230226039886, \"head\": 0.8997621349990368}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.01725960150361061, \"head\": 0.021719269454479218}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.023380238562822342, \"head\": 0.023567363619804382}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.14531611278653145, \"head\": 0.15685051307082176}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.1017049290239811, \"head\": 0.11867942661046982}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.7606776095926762, \"head\": 0.7954475395381451}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.017664238810539246, \"head\": 0.021314237266778946}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.027189936488866806, \"head\": 0.023148734122514725}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.18906790763139725, \"head\": 0.29949866980314255}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.10733184963464737, \"head\": 0.015001796185970306}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.7198318913578987, \"head\": 0.9286891259253025}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.01759868860244751, \"head\": 0.01736992597579956}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.023401282727718353, \"head\": 0.024155795574188232}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.2133372686803341, \"head\": 0.4130469784140587}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.12570210173726082, \"head\": 0.01516931876540184}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8393737301230431, \"head\": 0.7697543874382973}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.01822775974869728, \"head\": 0.01710987091064453}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02378489077091217, \"head\": 0.022969208657741547}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.24128396809101105, \"head\": 0.37919551506638527}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.029170338064432144, \"head\": 0.015178356319665909}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.824798371642828, \"head\": 0.8429140895605087}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.017426054924726486, \"head\": 0.016691379249095917}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02338922768831253, \"head\": 0.025325089693069458}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.17513129115104675, \"head\": 0.7620327062904835}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.02675792947411537, \"head\": 0.014862891286611557}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8223394192755222, \"head\": 0.7834519296884537}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.01659679040312767, \"head\": 0.016716737300157547}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.023273099213838577, \"head\": 0.023092910647392273}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.1404135264456272, \"head\": 0.2671452946960926}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.04734450951218605, \"head\": 0.015373017638921738}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8109389543533325, \"head\": 0.773231279104948}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.017527986317873, \"head\": 0.01715819537639618}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02317500114440918, \"head\": 0.023259975016117096}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.3032977357506752, \"head\": 0.3529411070048809}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.12101456895470619, \"head\": 0.056123510003089905}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.9087425917387009, \"head\": 0.7723695300519466}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.01709580421447754, \"head\": 0.016581468284130096}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.023299511522054672, \"head\": 0.026256609708070755}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.31924862414598465, \"head\": 0.3754034824669361}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.16147517412900925, \"head\": 0.0188911072909832}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.7581131793558598, \"head\": 0.8376064784824848}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.016900021582841873, \"head\": 0.018909964710474014}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.023251280188560486, \"head\": 0.024555552750825882}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.18740897625684738, \"head\": 0.3247509188950062}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.10189342498779297, \"head\": 0.01491013914346695}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8067094795405865, \"head\": 0.8341011628508568}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.016482558101415634, \"head\": 0.017900846898555756}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.022762779146432877, \"head\": 0.02372019737958908}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.18646133318543434, \"head\": 0.3982837423682213}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.10392019152641296, \"head\": 0.014882449060678482}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.8257374875247478, \"head\": 0.7651278711855412}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.020281419157981873, \"head\": 0.016556575894355774}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02401215210556984, \"head\": 0.029509305953979492}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.14506423845887184, \"head\": 0.353590689599514}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.029305722564458847, \"head\": 0.014874666929244995}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.7828530557453632, \"head\": 0.8144787847995758}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.016955018043518066, \"head\": 0.019991647452116013}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.023175135254859924, \"head\": 0.022979728877544403}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.17585299536585808, \"head\": 0.4207514598965645}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.08652275055646896, \"head\": 0.014776501804590225}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.633902084082365, \"head\": 0.7439848184585571}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.016803324222564697, \"head\": 0.01679174229502678}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.022789843380451202, \"head\": 0.023081589490175247}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.2504490353167057, \"head\": 0.275515615940094}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.10144681110978127, \"head\": 0.01495378464460373}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.7861208841204643, \"head\": 0.7600668407976627}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.019385676831007004, \"head\": 0.017300426959991455}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.023226946592330933, \"head\": 0.02343929186463356}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.1393708810210228, \"head\": 0.1555454097688198}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.015156801789999008, \"head\": 0.015172425657510757}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.7248434945940971, \"head\": 0.9005028679966927}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.016685109585523605, \"head\": 0.02606210485100746}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02281707152724266, \"head\": 0.02757175639271736}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.17188803479075432, \"head\": 0.33091870322823524}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.11025168001651764, \"head\": 0.01489923894405365}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.7682975232601166, \"head\": 0.7749986425042152}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.017469704151153564, \"head\": 0.018628302961587906}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.02800637111067772, \"head\": 0.026379510760307312}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.19676216691732407, \"head\": 0.344091534614563}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.11380964145064354, \"head\": 0.015056777745485306}}, {\"sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs\": {\"base\": 0.7985575906932354, \"head\": 0.8368619419634342}, \"sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]\": {\"base\": 0.016995973885059357, \"head\": 0.01711658015847206}, \"sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]\": {\"base\": 0.022991269826889038, \"head\": 0.02338453009724617}, \"sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality\": {\"base\": 0.14961541816592216, \"head\": 0.22174380719661713}, \"sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]\": {\"base\": 0.11502173915505409, \"head\": 0.015053384006023407}}]",
  "efficiency_test": [
    "sklearn/model_selection/tests/test_validation.py::test_cross_validate_many_jobs",
    "sklearn/tests/test_common.py::test_non_meta_estimators[Birch-Birch-check_clustering(readonly_memmap=True)]",
    "sklearn/tests/test_common.py::test_non_meta_estimators[MiniBatchKMeans-MiniBatchKMeans-check_clustering(readonly_memmap=True)]",
    "sklearn/tests/test_random_projection.py::test_random_projection_embedding_quality",
    "sklearn/tree/tests/test_tree.py::test_sparse_input[multilabel-ExtraTreeClassifier]"
  ],
  "patch_functions": "{\"sklearn/metrics/pairwise.py\": [\"pairwise_distances\", \"pairwise_distances_chunked\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'sklearn/metrics/pairwise.py': ['pairwise_distances', 'pairwise_distances_chunked']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"sklearn/datasets/base.py\": [\"load_boston\", \"load_iris\", \"load_digits\"], \"sklearn/utils/estimator_checks.py\": [\"_yield_all_checks\", \"set_checking_parameters\"], \"sklearn/metrics/pairwise.py\": [\"euclidean_distances\"], \"sklearn/random_projection.py\": [\"sparse_random_matrix\"], \"sklearn/utils/deprecation.py\": [\"wrapped\"], \"sklearn/base.py\": [\"GaussianRandomProjection.fit_transform\", \"AdaBoostClassifier.get_params\"], \"sklearn/tree/tree.py\": [\"ExtraTreeClassifier.predict_log_proba\", \"ExtraTreeClassifier.predict\", \"ExtraTreeClassifier.fit\", \"ExtraTreeClassifier.predict_proba\"], \"sklearn/model_selection/_search.py\": [\"GridSearchCV\"], \"sklearn/svm/classes.py\": [\"SVC\"], \"sklearn/datasets/samples_generator.py\": [\"make_multilabel_classification\"], \"sklearn/model_selection/_validation.py\": [\"cross_validate\"], \"sklearn/preprocessing/label.py\": [\"MultiLabelBinarizer.fit\"], \"sklearn/utils/validation.py\": [\"check_random_state\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'sklearn/datasets/base.py': ['load_boston', 'load_iris', 'load_digits'], 'sklearn/utils/estimator_checks.py': ['_yield_all_checks', 'set_checking_parameters'], 'sklearn/metrics/pairwise.py': ['euclidean_distances'], 'sklearn/random_projection.py': ['sparse_random_matrix'], 'sklearn/utils/deprecation.py': ['wrapped'], 'sklearn/base.py': ['GaussianRandomProjection.fit_transform', 'AdaBoostClassifier.get_params'], 'sklearn/tree/tree.py': ['ExtraTreeClassifier.predict_log_proba', 'ExtraTreeClassifier.predict', 'ExtraTreeClassifier.fit', 'ExtraTreeClassifier.predict_proba'], 'sklearn/model_selection/_search.py': ['GridSearchCV'], 'sklearn/svm/classes.py': ['SVC'], 'sklearn/datasets/samples_generator.py': ['make_multilabel_classification'], 'sklearn/model_selection/_validation.py': ['cross_validate'], 'sklearn/preprocessing/label.py': ['MultiLabelBinarizer.fit'], 'sklearn/utils/validation.py': ['check_random_state']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.17080000000000012
}