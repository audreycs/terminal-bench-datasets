{
  "repo": "pydata/xarray",
  "instance_id": "pydata__xarray-9520",
  "patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex 37369afbf96..b5441fc273a 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -47,6 +47,7 @@\n     create_coords_with_default_indexes,\n )\n from xarray.core.dataset import Dataset\n+from xarray.core.extension_array import PandasExtensionArray\n from xarray.core.formatting import format_item\n from xarray.core.indexes import (\n     Index,\n@@ -3857,7 +3858,11 @@ def to_pandas(self) -> Self | pd.Series | pd.DataFrame:\n         \"\"\"\n         # TODO: consolidate the info about pandas constructors and the\n         # attributes that correspond to their indexes into a separate module?\n-        constructors = {0: lambda x: x, 1: pd.Series, 2: pd.DataFrame}\n+        constructors: dict[int, Callable] = {\n+            0: lambda x: x,\n+            1: pd.Series,\n+            2: pd.DataFrame,\n+        }\n         try:\n             constructor = constructors[self.ndim]\n         except KeyError as err:\n@@ -3866,7 +3871,14 @@ def to_pandas(self) -> Self | pd.Series | pd.DataFrame:\n                 \"pandas objects. Requires 2 or fewer dimensions.\"\n             ) from err\n         indexes = [self.get_index(dim) for dim in self.dims]\n-        return constructor(self.values, *indexes)  # type: ignore[operator]\n+        if isinstance(self._variable._data, PandasExtensionArray):\n+            values = self._variable._data.array\n+        else:\n+            values = self.values\n+        pandas_object = constructor(values, *indexes)\n+        if isinstance(pandas_object, pd.Series):\n+            pandas_object.name = self.name\n+        return pandas_object\n \n     def to_dataframe(\n         self, name: Hashable | None = None, dim_order: Sequence[Hashable] | None = None\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex a8c1e004616..9b9239cc042 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -287,10 +287,13 @@ def as_compatible_data(\n     if isinstance(data, DataArray):\n         return cast(\"T_DuckArray\", data._variable._data)\n \n-    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n+    def convert_non_numpy_type(data):\n         data = _possibly_convert_datetime_or_timedelta_index(data)\n         return cast(\"T_DuckArray\", _maybe_wrap_data(data))\n \n+    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n+        return convert_non_numpy_type(data)\n+\n     if isinstance(data, tuple):\n         data = utils.to_0d_object_array(data)\n \n@@ -303,7 +306,11 @@ def as_compatible_data(\n \n     # we don't want nested self-described arrays\n     if isinstance(data, pd.Series | pd.DataFrame):\n-        data = data.values  # type: ignore[assignment]\n+        pandas_data = data.values\n+        if isinstance(pandas_data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n+            return convert_non_numpy_type(pandas_data)\n+        else:\n+            data = pandas_data\n \n     if isinstance(data, np.ma.MaskedArray):\n         mask = np.ma.getmaskarray(data)\n@@ -540,7 +547,7 @@ def _dask_finalize(self, results, array_func, *args, **kwargs):\n         return Variable(self._dims, data, attrs=self._attrs, encoding=self._encoding)\n \n     @property\n-    def values(self):\n+    def values(self) -> np.ndarray:\n         \"\"\"The variable's data as a numpy.ndarray\"\"\"\n         return _as_array_or_item(self._data)\n \n",
  "test_patch": "diff --git a/properties/test_pandas_roundtrip.py b/properties/test_pandas_roundtrip.py\nindex 3f507e3f341..8fc32e75cbd 100644\n--- a/properties/test_pandas_roundtrip.py\n+++ b/properties/test_pandas_roundtrip.py\n@@ -132,3 +132,12 @@ def test_roundtrip_pandas_dataframe_datetime(df) -> None:\n     roundtripped.columns.name = \"cols\"  # why?\n     pd.testing.assert_frame_equal(df, roundtripped)\n     xr.testing.assert_identical(dataset, roundtripped.to_xarray())\n+\n+\n+def test_roundtrip_1d_pandas_extension_array() -> None:\n+    df = pd.DataFrame({\"cat\": pd.Categorical([\"a\", \"b\", \"c\"])})\n+    arr = xr.Dataset.from_dataframe(df)[\"cat\"]\n+    roundtripped = arr.to_pandas()\n+    assert (df[\"cat\"] == roundtripped).all()\n+    assert df[\"cat\"].dtype == roundtripped.dtype\n+    xr.testing.assert_identical(arr, roundtripped.to_xarray())\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex f8a8878b8ee..0a55b42f228 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2671,11 +2671,12 @@ def test_full_like(self) -> None:\n         )\n \n         expect = orig.copy(deep=True)\n-        expect.values = [[2.0, 2.0], [2.0, 2.0]]\n+        # see https://github.com/python/mypy/issues/3004 for why we need to ignore type\n+        expect.values = [[2.0, 2.0], [2.0, 2.0]]  # type: ignore[assignment]\n         assert_identical(expect, full_like(orig, 2))\n \n         # override dtype\n-        expect.values = [[True, True], [True, True]]\n+        expect.values = [[True, True], [True, True]]  # type: ignore[assignment]\n         assert expect.dtype == bool\n         assert_identical(expect, full_like(orig, True, dtype=bool))\n \n",
  "base_commit": "3c74509c79c4e55f2f992633e8db9911b1e4f2f4",
  "head_commit": "570198d63b25b362487f41f0db774c194ca8b002",
  "created_at": 1726745967000,
  "version": "2024.05",
  "duration_changes": "[{\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.18732811510562897, \"head\": 0.18562466278672218}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.012016840279102325, \"head\": 0.011578362435102463}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.3942734263837337, \"head\": 1.5414976552128792}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.1870238408446312, \"head\": 0.1844634786248207}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.01115526631474495, \"head\": 0.01113850623369217}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.3719151876866817, \"head\": 1.388531155884266}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.19489581137895584, \"head\": 0.18611480668187141}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.01188221201300621, \"head\": 0.011422857642173767}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4721950367093086, \"head\": 1.5112100653350353}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.20169489085674286, \"head\": 0.1904016099870205}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011639513075351715, \"head\": 0.01144104078412056}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.3496332429349422, \"head\": 1.3648519217967987}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.1866961531341076, \"head\": 0.2015947364270687}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011477597057819366, \"head\": 0.011935926973819733}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4046577103435993, \"head\": 1.4659712724387646}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.1920788362622261, \"head\": 0.20222757756710052}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.01180696114897728, \"head\": 0.011908438056707382}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4318126663565636, \"head\": 1.4413086660206318}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.1982024908065796, \"head\": 0.20197273418307304}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011767756193876266, \"head\": 0.011895734816789627}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4311696738004684, \"head\": 1.3588365949690342}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.1912667080760002, \"head\": 0.18401488661766052}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.01158638671040535, \"head\": 0.011393651366233826}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.5841921120882034, \"head\": 1.4579620622098446}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.19004618376493454, \"head\": 0.19145028293132782}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.012028537690639496, \"head\": 0.011869113892316818}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.545928467065096, \"head\": 1.4517466686666012}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.19801973551511765, \"head\": 0.18784735724329948}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.012130346149206161, \"head\": 0.012447815388441086}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4312815479934216, \"head\": 1.488744668662548}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.18666227161884308, \"head\": 0.18284813314676285}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011410024017095566, \"head\": 0.011459901928901672}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4877920746803284, \"head\": 1.4157929122447968}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.18945668637752533, \"head\": 0.1876850500702858}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011485151946544647, \"head\": 0.011792819947004318}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4366518929600716, \"head\": 1.4534770622849464}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.18559008464217186, \"head\": 0.1837826929986477}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011470407247543335, \"head\": 0.011346682906150818}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.3104343637824059, \"head\": 1.340025532990694}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.18755554035305977, \"head\": 0.18965882435441017}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.01168007031083107, \"head\": 0.011689387261867523}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.3411762975156307, \"head\": 1.4399986043572426}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.19234935194253922, \"head\": 0.18484319373965263}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.01173713430762291, \"head\": 0.011471666395664215}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4308588616549969, \"head\": 1.4808630347251892}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.18173490837216377, \"head\": 0.19350237399339676}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.01137477159500122, \"head\": 0.011246252804994583}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.3492750711739063, \"head\": 1.4595887400209904}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.19102849066257477, \"head\": 0.18927038088440895}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.01265743374824524, \"head\": 0.011568807065486908}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.3554364927113056, \"head\": 1.5455790720880032}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.18716643750667572, \"head\": 0.18253590911626816}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011768732219934464, \"head\": 0.011229172348976135}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4577362462878227, \"head\": 1.4051938280463219}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.20346933603286743, \"head\": 0.19146273657679558}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011702578514814377, \"head\": 0.012199502438306808}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.4554774723947048, \"head\": 1.423182100057602}}, {\"xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]\": {\"base\": 0.18517479673027992, \"head\": 0.1887875236570835}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]\": {\"base\": 0.011201027780771255, \"head\": 0.011586304754018784}, \"xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]\": {\"base\": 1.3873878754675388, \"head\": 1.3984309397637844}}]",
  "efficiency_test": [
    "xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool-2]",
    "xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-min]",
    "xarray/tests/test_rolling.py::TestDatasetRolling::test_rolling_wrapped_bottleneck[1-numbagg-numpy-z2-1-True-var]"
  ],
  "patch_functions": "{\"xarray/core/dataarray.py\": [\"DataArray.to_pandas\"], \"xarray/core/variable.py\": [\"Variable.values\", \"as_compatible_data\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'xarray/core/dataarray.py': ['DataArray.to_pandas'], 'xarray/core/variable.py': ['Variable.values', 'as_compatible_data']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"xarray/core/dataset.py\": [\"Dataset.chunk\", \"Dataset.rolling\", \"Dataset.drop_vars\"], \"xarray/core/dataarray.py\": [\"DataArray.values\", \"DataArray.rolling\", \"DataArray.isel\", \"DataArray.chunk\", \"DataArray.coords\", \"DataArray.compute\", \"DataArray.drop_vars\", \"DataArray\"], \"xarray/core/rolling.py\": [\"DatasetRolling.method\"], \"xarray/core/indexes.py\": [\"PandasIndex.isel\"], \"xarray/namedarray/daskmanager.py\": [\"DaskManager.compute\"], \"xarray/util/deprecation_helpers.py\": [\"inner\"], \"xarray/namedarray/core.py\": [\"Variable.chunk\"], \"xarray/core/variable.py\": [\"IndexVariable.chunk\", \"Variable.chunk\", \"IndexVariable.isel\"], \"xarray/namedarray/pycompat.py\": [\"array_type\"], \"xarray/core/_aggregations.py\": [\"DataArray.min\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'xarray/core/dataset.py': ['Dataset.chunk', 'Dataset.rolling', 'Dataset.drop_vars'], 'xarray/core/dataarray.py': ['DataArray.values', 'DataArray.rolling', 'DataArray.isel', 'DataArray.chunk', 'DataArray.coords', 'DataArray.compute', 'DataArray.drop_vars', 'DataArray'], 'xarray/core/rolling.py': ['DatasetRolling.method'], 'xarray/core/indexes.py': ['PandasIndex.isel'], 'xarray/namedarray/daskmanager.py': ['DaskManager.compute'], 'xarray/util/deprecation_helpers.py': ['inner'], 'xarray/namedarray/core.py': ['Variable.chunk'], 'xarray/core/variable.py': ['IndexVariable.chunk', 'Variable.chunk', 'IndexVariable.isel'], 'xarray/namedarray/pycompat.py': ['array_type'], 'xarray/core/_aggregations.py': ['DataArray.min']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.0006666666666666666
}