{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-26940",
  "patch": "diff --git a/doc/src/modules/sets.rst b/doc/src/modules/sets.rst\nindex b59548756dff..c4cea3662d9c 100644\n--- a/doc/src/modules/sets.rst\n+++ b/doc/src/modules/sets.rst\n@@ -26,9 +26,6 @@ Elementary Sets\n Compound Sets\n -------------\n \n-.. module:: sympy.sets.sets\n-   :noindex:\n-\n .. autoclass:: Union\n    :members:\n \ndiff --git a/sympy/integrals/heurisch.py b/sympy/integrals/heurisch.py\nindex 5b9ce143bda9..a27e2700afd0 100644\n--- a/sympy/integrals/heurisch.py\n+++ b/sympy/integrals/heurisch.py\n@@ -504,15 +504,16 @@ def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3,\n         # optimizing the number of permutations of mapping              #\n         assert mapping[-1][0] == x # if not, find it and correct this comment\n         unnecessary_permutations = [mapping.pop(-1)]\n-        # only permute types of objects and let the ordering\n-        # of types take care of the order of replacement\n+        # permute types of objects\n         types = defaultdict(list)\n         for i in mapping:\n-            types[type(i)].append(i)\n+            e, _ = i\n+            types[type(e)].append(i)\n         mapping = [types[i] for i in types]\n         def _iter_mappings():\n             for i in permutations(mapping):\n-                yield [j for i in i for j in i]\n+                # make the expression of a given type be ordered\n+                yield [j for i in i for j in ordered(i)]\n         mappings = _iter_mappings()\n     else:\n         unnecessary_permutations = unnecessary_permutations or []\n",
  "test_patch": "diff --git a/.github/workflows/runtests.yml b/.github/workflows/runtests.yml\nindex 0b2fe10b6b88..13535aa99902 100644\n--- a/.github/workflows/runtests.yml\n+++ b/.github/workflows/runtests.yml\n@@ -187,27 +187,27 @@ jobs:\n       # Test modules with specific dependencies\n       - run: bin/test_optional_dependencies.py\n \n-  # -------------------- NumPy nightly ----------------------------- #\n+  # -------------------- Bleeding edge dependencies ----------------- #\n \n-  numpy-nightly:\n+  bleeding-edge:\n     needs: code-quality\n-\n-    runs-on: ubuntu-20.04\n-\n-    name: NumPy/SciPy nightly\n-\n+    name: Bleeding edge dependencies\n+    runs-on: ubuntu-24.04\n     steps:\n       - uses: actions/checkout@v4\n       - uses: actions/setup-python@v5\n         with:\n-          python-version: 3.12\n-\n-      - run: pip install -r requirements-dev.txt\n+          python-version: '3.12'\n+      - run: sudo apt-get update\n+      - run: sudo apt-get install libgmp-dev libmpfr-dev libmpc-dev libflint-dev\n+      - run: pip install git+https://github.com/flintlib/python-flint.git@master\n+      - run: pip install git+https://github.com/aleaxit/gmpy.git@master\n+      - run: pip install git+https://github.com/mpmath/mpmath.git@master\n       - run: pip install -i https://pypi.anaconda.org/scientific-python-nightly-wheels/simple numpy\n       - run: pip install -i https://pypi.anaconda.org/scientific-python-nightly-wheels/simple scipy\n-\n-      # Test modules with specific dependencies\n-      - run: bin/test_optional_dependencies.py\n+      - run: pip install -r requirements-dev.txt\n+      - run: pip install .\n+      - run: pytest -n auto\n \n   # -------------------- FLINT tests -------------------------------- #\n \ndiff --git a/sympy/integrals/tests/test_heurisch.py b/sympy/integrals/tests/test_heurisch.py\nindex 265186acd7fd..3a5236a942f5 100644\n--- a/sympy/integrals/tests/test_heurisch.py\n+++ b/sympy/integrals/tests/test_heurisch.py\n@@ -19,6 +19,8 @@\n from sympy.integrals.heurisch import components, heurisch, heurisch_wrapper\n from sympy.testing.pytest import XFAIL, slow\n from sympy.integrals.integrals import integrate\n+from sympy import S\n+\n x, y, z, nu = symbols('x,y,z,nu')\n f = Function('f')\n \n@@ -368,6 +370,8 @@ def test_heurisch_complex_erf_issue_26338():\n \n     a = exp(-x**2/(2*(2 - I)**2))\n     assert heurisch(a, x, hints=[]) is None  # None, not a wrong soln\n+    a = exp(-r**2/(2*(2 - I)**2))\n+    assert heurisch(a, r, hints=[]) is None\n     a = sqrt(pi)*erf((1 + I)/2)/2\n     assert integrate(exp(-I*x**2/2), (x, 0, 1)) == a - I*a\n \n@@ -387,3 +391,29 @@ def test_issue_15498():\n     integrand = m*m.subs(t, s)**-1*f_vec.subs(aif_eq.lhs, aif_eq.rhs).subs(t, s)\n     solution = integrate(integrand[0], (s, 0, t))\n     assert solution is not None  # does not hang and takes less than 10 s\n+\n+\n+@slow\n+def test_heurisch_issue_26930():\n+    integrand = x**Rational(4, 3)*log(x)\n+    anti = 3*x**(S(7)/3)*log(x)/7 - 9*x**(S(7)/3)/49\n+    assert heurisch(integrand, x) == anti\n+    assert integrate(integrand, x) == anti\n+    assert integrate(integrand, (x, 0, 1)) == -S(9)/49\n+\n+\n+def test_heurisch_issue_26922():\n+\n+    a, b, x = symbols(\"a, b, x\", real=True, positive=True)\n+    C = symbols(\"C\", real=True)\n+    i1 = -C*x*exp(-a*x**2 - sqrt(b)*x)\n+    i2 = C*x*exp(-a*x**2 + sqrt(b)*x)\n+    i = Integral(i1, x) + Integral(i2, x)\n+    res = (\n+        -C*exp(-a*x**2)*exp(sqrt(b)*x)/(2*a)\n+        + C*exp(-a*x**2)*exp(-sqrt(b)*x)/(2*a)\n+        + sqrt(pi)*C*sqrt(b)*exp(b/(4*a))*erf(sqrt(a)*x - sqrt(b)/(2*sqrt(a)))/(4*a**(S(3)/2))\n+        + sqrt(pi)*C*sqrt(b)*exp(b/(4*a))*erf(sqrt(a)*x + sqrt(b)/(2*sqrt(a)))/(4*a**(S(3)/2))\n+    )\n+\n+    assert i.doit(heurisch=False).expand() == res\ndiff --git a/sympy/integrals/tests/test_integrals.py b/sympy/integrals/tests/test_integrals.py\nindex 8436d6127c97..97b4dd4b30bc 100644\n--- a/sympy/integrals/tests/test_integrals.py\n+++ b/sympy/integrals/tests/test_integrals.py\n@@ -1146,8 +1146,8 @@ def test_issue_3940():\n     a, b, c, d = symbols('a:d', positive=True)\n     assert integrate(exp(-x**2 + I*c*x), x) == \\\n         -sqrt(pi)*exp(-c**2/4)*erf(I*c/2 - x)/2\n-    assert integrate(exp(a*x**2 + b*x + c), x) == \\\n-        sqrt(pi)*exp(c - b**2/(4*a))*erfi((2*a*x + b)/(2*sqrt(a)))/(2*sqrt(a))\n+    assert integrate(exp(a*x**2 + b*x + c), x).equals(\n+        sqrt(pi)*exp(c - b**2/(4*a))*erfi((2*a*x + b)/(2*sqrt(a)))/(2*sqrt(a)))\n \n     from sympy.core.function import expand_mul\n     from sympy.abc import k\ndiff --git a/sympy/stats/sampling/tests/test_sample_discrete_rv.py b/sympy/stats/sampling/tests/test_sample_discrete_rv.py\nindex 10029af647b9..df73eb24d0e7 100644\n--- a/sympy/stats/sampling/tests/test_sample_discrete_rv.py\n+++ b/sympy/stats/sampling/tests/test_sample_discrete_rv.py\n@@ -1,7 +1,7 @@\n from sympy.core.singleton import S\n-from sympy.core.symbol import Symbol\n+#from sympy.core.symbol import Symbol\n from sympy.external import import_module\n-from sympy.stats import Geometric, Poisson, Zeta, sample, Skellam, DiscreteRV, Logarithmic, NegativeBinomial, YuleSimon\n+from sympy.stats import Geometric, Poisson, Zeta, sample, Skellam, Logarithmic, NegativeBinomial, YuleSimon\n from sympy.testing.pytest import skip, raises, slow\n \n \n@@ -27,11 +27,13 @@ def test_sample_numpy():\n \n \n def test_sample_scipy():\n-    p = S(2)/3\n-    x = Symbol('x', integer=True, positive=True)\n-    pdf = p*(1 - p)**(x - 1) # pdf of Geometric Distribution\n+    #p = S(2)/3\n+    #x = Symbol('x', integer=True, positive=True)\n+    #pdf = p*(1 - p)**(x - 1) # pdf of Geometric Distribution\n     distribs_scipy = [\n-        DiscreteRV(x, pdf, set=S.Naturals),\n+        # This one fails:\n+        #    https://github.com/sympy/sympy/issues/26862\n+        # DiscreteRV(x, pdf, set=S.Naturals),\n         Geometric('G', 0.5),\n         Logarithmic('L', 0.5),\n         NegativeBinomial('N', 5, 0.4),\n",
  "base_commit": "5b2c92a8e024160a9b883cd3cfa95c0f5698bdab",
  "head_commit": "9ddff227329b82d0a1536e53eb08066765f58935",
  "created_at": 1723237122000,
  "version": "1.13",
  "duration_changes": "[{\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.168551005423069, \"head\": 1.2423247285187244}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.199743766337633, \"head\": 1.2491042912006378}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1675992347300053, \"head\": 1.2783454097807407}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1337781958281994, \"head\": 1.2305054180324078}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1878670565783978, \"head\": 1.2708800807595253}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1311808452010155, \"head\": 1.248367965221405}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1523455418646336, \"head\": 1.2390644885599613}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1916537918150425, \"head\": 1.2594993971288204}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1527671962976456, \"head\": 1.2224379256367683}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.2260389365255833, \"head\": 1.2401923686265945}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.219619031995535, \"head\": 1.2391332760453224}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.2033616825938225, \"head\": 1.2312669977545738}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.225482691079378, \"head\": 1.2382530383765697}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.201891366392374, \"head\": 1.2238443195819855}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1391267254948616, \"head\": 1.2388696186244488}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1605415157973766, \"head\": 1.2385801747441292}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.199146281927824, \"head\": 1.2313615381717682}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1371794529259205, \"head\": 1.2362761422991753}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1441601663827896, \"head\": 1.218856304883957}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1230784207582474, \"head\": 1.2355956099927425}}]",
  "efficiency_test": [
    "sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative"
  ],
  "patch_functions": "{\"sympy/integrals/heurisch.py\": [\"heurisch\", \"heurisch._iter_mappings\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'sympy/integrals/heurisch.py': ['heurisch', 'heurisch._iter_mappings']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"sympy/functions/elementary/exponential.py\": [\"log\"], \"sympy/core/decorators.py\": [\"Symbol._func\"], \"sympy/core/cache.py\": [\"wrapper\"], \"sympy/core/symbol.py\": [\"symbols\"], \"sympy/functions/elementary/trigonometric.py\": [\"tan\", \"cos\", \"sec\"], \"sympy/integrals/integrals.py\": [\"integrate\"], \"sympy/core/function.py\": [\"Derivative\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'sympy/functions/elementary/exponential.py': ['log'], 'sympy/core/decorators.py': ['Symbol._func'], 'sympy/core/cache.py': ['wrapper'], 'sympy/core/symbol.py': ['symbols'], 'sympy/functions/elementary/trigonometric.py': ['tan', 'cos', 'sec'], 'sympy/integrals/integrals.py': ['integrate'], 'sympy/core/function.py': ['Derivative']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.4270000000000003
}