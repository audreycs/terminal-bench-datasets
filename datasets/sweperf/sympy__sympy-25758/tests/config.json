{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-25758",
  "patch": "diff --git a/sympy/solvers/inequalities.py b/sympy/solvers/inequalities.py\nindex 246a752c3106..8e6e2f63552b 100644\n--- a/sympy/solvers/inequalities.py\n+++ b/sympy/solvers/inequalities.py\n@@ -10,7 +10,7 @@\n from sympy.sets.sets import Interval, FiniteSet, Union, Intersection\n from sympy.core.singleton import S\n from sympy.core.function import expand_mul\n-from sympy.functions.elementary.complexes import im, Abs\n+from sympy.functions.elementary.complexes import Abs\n from sympy.logic import And\n from sympy.polys import Poly, PolynomialError, parallel_poly_from_expr\n from sympy.polys.polyutils import _nsort\n@@ -592,11 +592,11 @@ def valid(x):\n             # If expr contains imaginary coefficients, only take real\n             # values of x for which the imaginary part is 0\n             make_real = S.Reals\n-            if im(expanded_e) != S.Zero:\n+            if (coeffI := expanded_e.coeff(S.ImaginaryUnit)) != S.Zero:\n                 check = True\n                 im_sol = FiniteSet()\n                 try:\n-                    a = solveset(im(expanded_e), gen, domain)\n+                    a = solveset(coeffI, gen, domain)\n                     if not isinstance(a, Interval):\n                         for z in a:\n                             if z not in singularities and valid(z) and z.is_extended_real:\n@@ -665,7 +665,7 @@ def valid(x):\n             if valid(_pt(start, end)):\n                 sol_sets.append(Interval.open(start, end))\n \n-            if im(expanded_e) != S.Zero and check:\n+            if coeffI != S.Zero and check:\n                 rv = (make_real).intersect(_domain)\n             else:\n                 rv = Intersection(\ndiff --git a/sympy/solvers/solvers.py b/sympy/solvers/solvers.py\nindex 758888bb0301..e89929950d40 100644\n--- a/sympy/solvers/solvers.py\n+++ b/sympy/solvers/solvers.py\n@@ -3144,7 +3144,7 @@ def _invert(eq, *symbols, **kwargs):\n \n     >>> invert(sqrt(x + y) - 2)\n     (4, x + y)\n-    >>> invert(sqrt(x + y) - 2)\n+    >>> invert(sqrt(x + y) + 2)  # note +2 instead of -2\n     (4, x + y)\n \n     If the exponent is an Integer, setting ``integer_power`` to True\n",
  "test_patch": "diff --git a/sympy/core/tests/test_relational.py b/sympy/core/tests/test_relational.py\nindex 83c5e1b31392..723ec4cafe69 100644\n--- a/sympy/core/tests/test_relational.py\n+++ b/sympy/core/tests/test_relational.py\n@@ -800,10 +800,10 @@ def test_simplify_relational():\n     assert Lt(x, 2).simplify() == Lt(x, 2)\n     assert Lt(-x, 2).simplify() == Gt(x, -2)\n \n-    # Test particulat branches of _eval_simplify\n+    # Test particular branches of _eval_simplify\n     m = exp(1) - exp_polar(1)\n     assert simplify(m*x > 1) is S.false\n-    # These two tests the same branch\n+    # These two test the same branch\n     assert simplify(m*x + 2*m*y > 1) is S.false\n     assert simplify(m*x + y > 1 + y) is S.false\n \ndiff --git a/sympy/solvers/tests/test_inequalities.py b/sympy/solvers/tests/test_inequalities.py\nindex 383c6a183e24..4fc143b5e5b3 100644\n--- a/sympy/solvers/tests/test_inequalities.py\n+++ b/sympy/solvers/tests/test_inequalities.py\n@@ -485,3 +485,7 @@ def test__pt():\n     assert _pt(x, oo) == _pt(oo, x) == x + 1\n     assert _pt(x, -oo) == _pt(-oo, x) == x - 1\n     raises(ValueError, lambda: _pt(Dummy('i', infinite=True), S.One))\n+\n+\n+def test_issue_25697():\n+    assert _solve_inequality(log(x, 3) <= 2, x) == (x <= 9) & (S.Zero < x)\ndiff --git a/sympy/utilities/tests/test_wester.py b/sympy/utilities/tests/test_wester.py\nindex cb90b48566ca..00f47b6b795b 100644\n--- a/sympy/utilities/tests/test_wester.py\n+++ b/sympy/utilities/tests/test_wester.py\n@@ -950,11 +950,12 @@ def test_M8():\n @XFAIL\n def test_M9():\n     # x = symbols('x')\n+    # solutions are 1/2*(1 +/- sqrt(9 + 8*I*pi*n)) for integer n\n     raise NotImplementedError(\"solveset(exp(2-x**2)-exp(-x),x) has complex solutions.\")\n \n \n def test_M10():\n-    # TODO: Replace solve with solveset, as of now test fails for solveset\n+    # TODO: Replace solve with solveset when it gives Lambert solution\n     assert solve(exp(x) - x, x) == [-LambertW(-1)]\n \n \n",
  "base_commit": "182ccf8cba988d35e4adb2e418b1a20992fe549f",
  "head_commit": "7350b3a524e435ce110003f709274f3d47b268d9",
  "created_at": 1696378897000,
  "version": "1.13",
  "duration_changes": "[{\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7182350344955921, \"head\": 0.5798512771725655}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.3045857697725296, \"head\": 0.17846718430519104}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.2921279966831207, \"head\": 0.2887685149908066}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7417791932821274, \"head\": 0.5927285477519035}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.29271724447607994, \"head\": 0.18048758432269096}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.29046886786818504, \"head\": 0.2880829945206642}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7307579815387726, \"head\": 0.5931423082947731}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.29317421838641167, \"head\": 0.17966409772634506}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28538620844483376, \"head\": 0.28482673317193985}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7047669254243374, \"head\": 0.590376652777195}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2944164425134659, \"head\": 0.17751064524054527}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.2838430441915989, \"head\": 0.2867809645831585}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7330555431544781, \"head\": 0.5956557206809521}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2923653721809387, \"head\": 0.17889614030718803}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28579025715589523, \"head\": 0.28743963316082954}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7079007476568222, \"head\": 0.601936798542738}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2890116982161999, \"head\": 0.17636986076831818}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28448645398020744, \"head\": 0.28512515127658844}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7346178516745567, \"head\": 0.5879534184932709}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2903585694730282, \"head\": 0.18461096659302711}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28444770351052284, \"head\": 0.28715385496616364}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.722276858985424, \"head\": 0.5960631035268307}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.288996797055006, \"head\": 0.17878194898366928}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.2861359678208828, \"head\": 0.2848114185035229}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7156482301652431, \"head\": 0.5908788405358791}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2880754731595516, \"head\": 0.1816718392074108}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28648724779486656, \"head\": 0.28281278163194656}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7313782162964344, \"head\": 0.5774205960333347}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.29149889945983887, \"head\": 0.17342734709382057}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28908878937363625, \"head\": 0.28350890800356865}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.6999046690762043, \"head\": 0.5957616455852985}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.294526569545269, \"head\": 0.18075980991125107}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.285043865442276, \"head\": 0.2866494655609131}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7472203075885773, \"head\": 0.5717182606458664}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.29367048665881157, \"head\": 0.18093158677220345}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.2882191464304924, \"head\": 0.2962184548377991}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7192468717694283, \"head\": 0.5997921973466873}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2896311990916729, \"head\": 0.1719605103135109}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28417375311255455, \"head\": 0.2839099243283272}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7087043896317482, \"head\": 0.5729275234043598}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2989521920681, \"head\": 0.1706615835428238}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28484708070755005, \"head\": 0.26968051493167877}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7251946963369846, \"head\": 0.5735802836716175}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2863195315003395, \"head\": 0.17349166050553322}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.2806559279561043, \"head\": 0.2814670577645302}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7405084818601608, \"head\": 0.5738230273127556}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2955158017575741, \"head\": 0.16704559326171875}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28904298692941666, \"head\": 0.29221194982528687}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7226329669356346, \"head\": 0.5702228285372257}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2924901880323887, \"head\": 0.1708262339234352}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.2881905101239681, \"head\": 0.2673514671623707}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7233910337090492, \"head\": 0.5836825147271156}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.30631915107369423, \"head\": 0.17550046741962433}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.2910521924495697, \"head\": 0.2684868536889553}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7298281453549862, \"head\": 0.5585388690233231}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.29556072503328323, \"head\": 0.16320186480879784}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28843164443969727, \"head\": 0.2660047709941864}}, {\"sympy/solvers/tests/test_solveset.py::test_issue_11064\": {\"base\": 0.7291879579424858, \"head\": 0.5522980093955994}, \"sympy/solvers/tests/test_solveset.py::test_issue_17565\": {\"base\": 0.2895682603120804, \"head\": 0.1676061488687992}, \"sympy/stats/tests/test_continuous_rv.py::test_maxwell\": {\"base\": 0.28279436007142067, \"head\": 0.27862507477402687}}]",
  "efficiency_test": [
    "sympy/solvers/tests/test_solveset.py::test_issue_11064",
    "sympy/solvers/tests/test_solveset.py::test_issue_17565",
    "sympy/stats/tests/test_continuous_rv.py::test_maxwell"
  ],
  "patch_functions": "{\"sympy/solvers/inequalities.py\": [\"solve_univariate_inequality\"], \"sympy/solvers/solvers.py\": [\"_invert\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'sympy/solvers/inequalities.py': ['solve_univariate_inequality'], 'sympy/solvers/solvers.py': ['_invert']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"sympy/core/decorators.py\": [\"Symbol._func\"], \"sympy/sets/sets.py\": [\"Lopen\", \"Interval\", \"Union\"], \"sympy/core/function.py\": [\"diff\"], \"sympy/stats/rv.py\": [\"cdf\", \"expectation\", \"density\"], \"sympy/core/cache.py\": [\"wrapper\"], \"sympy/functions/elementary/miscellaneous.py\": [\"sqrt\"], \"sympy/core/symbol.py\": [\"Symbol\"], \"sympy/core/numbers.py\": [\"Rational\", \"Integer\"], \"sympy/functions/elementary/exponential.py\": [\"exp\", \"exp.exp\"], \"sympy/stats/rv_interface.py\": [\"variance\"], \"sympy/stats/crv.py\": [\"MaxwellDistribution.cdf\"], \"sympy/functions/special/error_functions.py\": [\"erf\"], \"sympy/solvers/solveset.py\": [\"solveset\"], \"sympy/stats/crv_types.py\": [\"Maxwell\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'sympy/core/decorators.py': ['Symbol._func'], 'sympy/sets/sets.py': ['Lopen', 'Interval', 'Union'], 'sympy/core/function.py': ['diff'], 'sympy/stats/rv.py': ['cdf', 'expectation', 'density'], 'sympy/core/cache.py': ['wrapper'], 'sympy/functions/elementary/miscellaneous.py': ['sqrt'], 'sympy/core/symbol.py': ['Symbol'], 'sympy/core/numbers.py': ['Rational', 'Integer'], 'sympy/functions/elementary/exponential.py': ['exp', 'exp.exp'], 'sympy/stats/rv_interface.py': ['variance'], 'sympy/stats/crv.py': ['MaxwellDistribution.cdf'], 'sympy/functions/special/error_functions.py': ['erf'], 'sympy/solvers/solveset.py': ['solveset'], 'sympy/stats/crv_types.py': ['Maxwell']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.19100000000000014
}