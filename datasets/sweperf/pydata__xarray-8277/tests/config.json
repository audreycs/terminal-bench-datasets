{
  "repo": "pydata/xarray",
  "instance_id": "pydata__xarray-8277",
  "patch": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex 55e0fbaf177..568fa62aff6 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -49,6 +49,9 @@ Bug fixes\n - :py:meth:`DataArray.rename` & :py:meth:`Dataset.rename` would emit a warning\n   when the operation was a no-op. (:issue:`8266`)\n   By `Simon Hansen <https://github.com/hoxbro>`_.\n+- Fixed a regression introduced in the previous release checking time-like units\n+  when encoding/decoding masked data (:issue:`8269`, :pull:`8277`).\n+  By `Kai M\u00fchlbauer <https://github.com/kmuehlbauer>`_.\n \n \n Documentation\ndiff --git a/xarray/coding/variables.py b/xarray/coding/variables.py\nindex c583afc93c2..df660f90d9e 100644\n--- a/xarray/coding/variables.py\n+++ b/xarray/coding/variables.py\n@@ -217,8 +217,9 @@ def _apply_mask(\n \n def _is_time_like(units):\n     # test for time-like\n+    if units is None:\n+        return False\n     time_strings = [\n-        \"since\",\n         \"days\",\n         \"hours\",\n         \"minutes\",\n@@ -227,7 +228,19 @@ def _is_time_like(units):\n         \"microseconds\",\n         \"nanoseconds\",\n     ]\n-    return any(tstr in str(units) for tstr in time_strings)\n+    units = str(units)\n+    # to prevent detecting units like `days accumulated` as time-like\n+    # special casing for datetime-units and timedelta-units (GH-8269)\n+    if \"since\" in units:\n+        from xarray.coding.times import _unpack_netcdf_time_units\n+\n+        try:\n+            _unpack_netcdf_time_units(units)\n+        except ValueError:\n+            return False\n+        return True\n+    else:\n+        return any(tstr == units for tstr in time_strings)\n \n \n class CFMaskCoder(VariableCoder):\n",
  "test_patch": "diff --git a/xarray/tests/test_conventions.py b/xarray/tests/test_conventions.py\nindex 5157688b629..d6d1303a696 100644\n--- a/xarray/tests/test_conventions.py\n+++ b/xarray/tests/test_conventions.py\n@@ -333,6 +333,17 @@ def test_invalid_time_units_raises_eagerly(self) -> None:\n         with pytest.raises(ValueError, match=r\"unable to decode time\"):\n             decode_cf(ds)\n \n+    @pytest.mark.parametrize(\"decode_times\", [True, False])\n+    def test_invalid_timedelta_units_do_not_decode(self, decode_times) -> None:\n+        # regression test for #8269\n+        ds = Dataset(\n+            {\"time\": (\"time\", [0, 1, 20], {\"units\": \"days invalid\", \"_FillValue\": 20})}\n+        )\n+        expected = Dataset(\n+            {\"time\": (\"time\", [0.0, 1.0, np.nan], {\"units\": \"days invalid\"})}\n+        )\n+        assert_identical(expected, decode_cf(ds, decode_times=decode_times))\n+\n     @requires_cftime\n     def test_dataset_repr_with_netcdf4_datetimes(self) -> None:\n         # regression test for #347\n",
  "base_commit": "2cd8f96a1b5ae954d7b34390e8b01fbd985fc710",
  "head_commit": "d29dcf9373618caca0d39e426035bf4ccdf8ef75",
  "created_at": 1696578363000,
  "version": "2023.07",
  "duration_changes": "[{\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.18357956036925316, \"head\": 0.17849791049957275}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.019390538334846497, \"head\": 0.01793856918811798}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.18265380710363388, \"head\": 0.17876050621271133}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.026069626212120056, \"head\": 0.02059262990951538}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17975648865103722, \"head\": 0.17917538434267044}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.017914526164531708, \"head\": 0.01867329701781273}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17802447080612183, \"head\": 0.1820158250629902}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.018281102180480957, \"head\": 0.017943866550922394}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17848088964819908, \"head\": 0.1830723024904728}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.018321268260478973, \"head\": 0.01879696547985077}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17626508325338364, \"head\": 0.17543819546699524}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.01780569925904274, \"head\": 0.01783355325460434}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.20456968620419502, \"head\": 0.17996644228696823}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.019517969340085983, \"head\": 0.017756767570972443}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.18064606562256813, \"head\": 0.18042877316474915}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.018931154161691666, \"head\": 0.01848938688635826}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17749221995472908, \"head\": 0.17907820269465446}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.01829274743795395, \"head\": 0.021024353802204132}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.1798512041568756, \"head\": 0.17910966277122498}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.019788779318332672, \"head\": 0.018367085605859756}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17586714401841164, \"head\": 0.18630602210760117}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.01734789088368416, \"head\": 0.019336998462677002}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.18614782392978668, \"head\": 0.18212755396962166}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.019613660871982574, \"head\": 0.028327040374279022}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17815281078219414, \"head\": 0.17799900099635124}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.01818370819091797, \"head\": 0.01770506054162979}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17805009335279465, \"head\": 0.17806854471564293}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.020880017429590225, \"head\": 0.017856035381555557}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17694293707609177, \"head\": 0.1773797571659088}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.019024189561605453, \"head\": 0.01807059347629547}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.18952959775924683, \"head\": 0.18731795623898506}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.021358948200941086, \"head\": 0.01796223595738411}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.1811826080083847, \"head\": 0.18268895894289017}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.019338801503181458, \"head\": 0.01839543879032135}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.18048018962144852, \"head\": 0.17979143932461739}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.018539346754550934, \"head\": 0.017710566520690918}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.17804983258247375, \"head\": 0.18168924003839493}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.021826088428497314, \"head\": 0.02016320824623108}}, {\"xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]\": {\"base\": 0.18386170640587807, \"head\": 0.17759020999073982}, \"xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]\": {\"base\": 0.01870311051607132, \"head\": 0.017837516963481903}}]",
  "efficiency_test": [
    "xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]",
    "xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]"
  ],
  "patch_functions": "{\"xarray/coding/variables.py\": [\"_is_time_like\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'xarray/coding/variables.py': ['_is_time_like']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"xarray/core/dataset.py\": [\"Dataset.chunk\"], \"xarray/core/dataarray.py\": [\"DataArray.values\", \"DataArray.data\", \"DataArray.to_series\", \"DataArray.chunk\", \"DataArray.dtype\", \"DataArray.compute\", \"DataArray\"], \"xarray/core/variable.py\": [\"Variable.quantile\", \"Variable.data\", \"IndexVariable.chunk\", \"Variable\", \"Variable.chunk\", \"Variable.values\"], \"xarray/core/common.py\": [\"Variable.get_axis_num\"], \"xarray/util/deprecation_helpers.py\": [\"inner\"], \"xarray/core/dtypes.py\": [\"maybe_promote\"], \"xarray/core/pycompat.py\": [\"array_type\"], \"xarray/core/_aggregations.py\": [\"DataArray.min\"], \"xarray/core/utils.py\": [\"dict_equiv\"], \"xarray/core/daskmanager.py\": [\"DaskManager.compute\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'xarray/core/dataset.py': ['Dataset.chunk'], 'xarray/core/dataarray.py': ['DataArray.values', 'DataArray.data', 'DataArray.to_series', 'DataArray.chunk', 'DataArray.dtype', 'DataArray.compute', 'DataArray'], 'xarray/core/variable.py': ['Variable.quantile', 'Variable.data', 'IndexVariable.chunk', 'Variable', 'Variable.chunk', 'Variable.values'], 'xarray/core/common.py': ['Variable.get_axis_num'], 'xarray/util/deprecation_helpers.py': ['inner'], 'xarray/core/dtypes.py': ['maybe_promote'], 'xarray/core/pycompat.py': ['array_type'], 'xarray/core/_aggregations.py': ['DataArray.min'], 'xarray/core/utils.py': ['dict_equiv'], 'xarray/core/daskmanager.py': ['DaskManager.compute']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.008500000000000004
}