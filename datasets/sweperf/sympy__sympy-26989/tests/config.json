{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-26989",
  "patch": "diff --git a/sympy/series/gruntz.py b/sympy/series/gruntz.py\nindex 0bf3bf3e50b1..f09caf9b4de3 100644\n--- a/sympy/series/gruntz.py\n+++ b/sympy/series/gruntz.py\n@@ -120,6 +120,7 @@\n \n from sympy.core import Basic, S, Mul, PoleError\n from sympy.core.cache import cacheit\n+from sympy.core.function import AppliedUndef\n from sympy.core.intfunc import ilcm\n from sympy.core.numbers import I, oo\n from sympy.core.symbol import Dummy, Wild\n@@ -301,6 +302,8 @@ def mrv(e, x):\n         else:\n             s, expr = mrv(e.exp, x)\n             return s, exp(expr)\n+    elif isinstance(e, AppliedUndef):\n+        raise ValueError(\"MRV set computation for UndefinedFunction is not allowed\")\n     elif e.is_Function:\n         l = [mrv(a, x) for a in e.args]\n         l2 = [s for (s, _) in l if s != SubsSet()]\ndiff --git a/sympy/series/limits.py b/sympy/series/limits.py\nindex b3976e551227..5c1fa0b25836 100644\n--- a/sympy/series/limits.py\n+++ b/sympy/series/limits.py\n@@ -2,6 +2,7 @@\n from sympy.core import S, Symbol, Add, sympify, Expr, PoleError, Mul\n from sympy.core.exprtools import factor_terms\n from sympy.core.numbers import Float, _illegal\n+from sympy.core.function import AppliedUndef\n from sympy.functions.combinatorial.factorials import factorial\n from sympy.functions.elementary.complexes import (Abs, sign, arg, re)\n from sympy.functions.elementary.exponential import (exp, log)\n@@ -77,7 +78,7 @@ def heuristics(e, z, z0, dir):\n         rv = limit(e.subs(z, 1/z), z, S.Zero, \"+\")\n         if isinstance(rv, Limit):\n             return\n-    elif e.is_Mul or e.is_Add or e.is_Pow or e.is_Function:\n+    elif (e.is_Mul or e.is_Add or e.is_Pow or (e.is_Function and not isinstance(e, AppliedUndef))):\n         r = []\n         from sympy.simplify.simplify import together\n         for a in e.args:\n",
  "test_patch": "diff --git a/sympy/calculus/tests/test_finite_diff.py b/sympy/calculus/tests/test_finite_diff.py\nindex ce695c6c6ac7..e9ecfbdd61b1 100644\n--- a/sympy/calculus/tests/test_finite_diff.py\n+++ b/sympy/calculus/tests/test_finite_diff.py\n@@ -162,7 +162,3 @@ def test_differentiate_finite():\n            + 3*g(h + x)/(2*h))/(2*h) - (2*f(x)/h - 3*f(-h + x)/(2*h) - \\\n            f(h + x)/(2*h))*(2*g(x)/h - 3*g(-h + x)/(2*h) - g(h + x)/(2*h))/(2*h)\n     assert res5 == ref5\n-\n-    res6 = res5.limit(h, 0).doit()\n-    ref6 = diff(res5_expr, x)\n-    assert res6 == ref6\ndiff --git a/sympy/series/tests/test_gruntz.py b/sympy/series/tests/test_gruntz.py\nindex c11d243c7c1e..4cae15297048 100644\n--- a/sympy/series/tests/test_gruntz.py\n+++ b/sympy/series/tests/test_gruntz.py\n@@ -1,4 +1,5 @@\n from sympy.core import EulerGamma\n+from sympy.core.function import Function\n from sympy.core.numbers import (E, I, Integer, Rational, oo, pi)\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n@@ -12,7 +13,7 @@\n from sympy.functions.elementary.hyperbolic import cosh, coth, sinh, tanh\n from sympy.series.gruntz import compare, mrv, rewrite, mrv_leadterm, gruntz, \\\n     sign\n-from sympy.testing.pytest import XFAIL, skip, slow\n+from sympy.testing.pytest import XFAIL, raises, skip, slow\n \n \"\"\"\n This test suite is testing the limit algorithm using the bottom up approach.\n@@ -474,6 +475,14 @@ def test_issue_7096():\n     from sympy.functions import sign\n     assert gruntz(x**-pi, x, 0, dir='-') == oo*sign((-1)**(-pi))\n \n+\n+def test_issue_7391_8166():\n+    f = Function('f')\n+    # limit should depend on the continuity of the expression at the point passed\n+    raises(ValueError, lambda: gruntz(f(x), x, 4))\n+    raises(ValueError, lambda: gruntz(x*f(x)**2/(x**2 + f(x)**4), x, 0))\n+\n+\n def test_issue_24210_25885():\n     eq = exp(x)/(1+1/x)**x**2\n     ans = sqrt(E)\ndiff --git a/sympy/series/tests/test_limits.py b/sympy/series/tests/test_limits.py\nindex 4f2760f8e82a..94885748d903 100644\n--- a/sympy/series/tests/test_limits.py\n+++ b/sympy/series/tests/test_limits.py\n@@ -694,6 +694,13 @@ def test_issue_7224():\n     assert limit(x*diff(expr, x, x)/expr, x, 1).evalf() == 2.0\n \n \n+def test_issue_7391_8166():\n+    f = Function('f')\n+    # limit should depend on the continuity of the expression at the point passed\n+    assert limit(f(x), x, 4) == Limit(f(x), x, 4, dir='+')\n+    assert limit(x*f(x)**2/(x**2 + f(x)**4), x, 0) == Limit(x*f(x)**2/(x**2 + f(x)**4), x, 0, dir='+')\n+\n+\n def test_issue_8208():\n     assert limit(n**(Rational(1, 1e9) - 1), n, oo) == 0\n \n",
  "base_commit": "d943c977f9f12426a3ddf475a044f329f2033807",
  "head_commit": "042ed421e723c7b581a44c6626c0eaef354ef3a9",
  "created_at": 1724407305000,
  "version": "1.14",
  "duration_changes": "[{\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2602572850883007, \"head\": 0.2542131766676903}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.694187570363283, \"head\": 2.3072496354579926}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25456495210528374, \"head\": 0.25400585308671}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5509595684707165, \"head\": 2.3002102710306644}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2551882304251194, \"head\": 0.2537499628961086}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.62810318171978, \"head\": 2.2997056506574154}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25788629800081253, \"head\": 0.25437357276678085}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.587531939148903, \"head\": 2.274522937834263}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2524201571941376, \"head\": 0.2535182125866413}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.532298196107149, \"head\": 2.281589414924383}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2528492473065853, \"head\": 0.25138820335268974}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5723470374941826, \"head\": 2.3069109097123146}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2507179267704487, \"head\": 0.2557658888399601}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.4947234466671944, \"head\": 2.386634573340416}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25552861392498016, \"head\": 0.25405333936214447}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5812581814825535, \"head\": 2.3036494441330433}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25412216037511826, \"head\": 0.2531440630555153}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5548583269119263, \"head\": 2.3178854696452618}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2543848715722561, \"head\": 0.25449464842677116}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.555806625634432, \"head\": 2.3244199082255363}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25178370997309685, \"head\": 0.25793296471238136}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5164015144109726, \"head\": 2.3278041519224644}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25234033912420273, \"head\": 0.2519475109875202}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5368958488106728, \"head\": 2.2752061933279037}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2581086680293083, \"head\": 0.2470928579568863}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.528462190181017, \"head\": 2.3003795854747295}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25426481664180756, \"head\": 0.2597421705722809}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5247848965227604, \"head\": 2.2859798073768616}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2570121996104717, \"head\": 0.2517014965415001}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5863030701875687, \"head\": 2.216607253998518}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2556060217320919, \"head\": 0.25104836747050285}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5815081484615803, \"head\": 2.2028177939355373}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25625572726130486, \"head\": 0.2510547898709774}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.57178645581007, \"head\": 2.2389184311032295}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.25421686843037605, \"head\": 0.24495788291096687}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5549749433994293, \"head\": 2.201288428157568}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2546519637107849, \"head\": 0.2393542006611824}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.560691721737385, \"head\": 2.1762249432504177}}, {\"sympy/series/tests/test_residues.py::test_issue_5654\": {\"base\": 0.2560291551053524, \"head\": 0.23434267193078995}, \"sympy/solvers/ode/tests/test_ode.py::test_series\": {\"base\": 3.5575609281659126, \"head\": 2.212936580181122}}]",
  "efficiency_test": [
    "sympy/series/tests/test_residues.py::test_issue_5654",
    "sympy/solvers/ode/tests/test_ode.py::test_series"
  ],
  "patch_functions": "{\"sympy/series/gruntz.py\": [\"mrv\"], \"sympy/series/limits.py\": [\"heuristics\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'sympy/series/gruntz.py': ['mrv'], 'sympy/series/limits.py': ['heuristics']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"sympy/solvers/ode/ode.py\": [\"dsolve\"], \"sympy/functions/elementary/exponential.py\": [\"exp.exp\", \"exp\"], \"sympy/series/residues.py\": [\"residue\"], \"sympy/core/cache.py\": [\"wrapper\"], \"sympy/solvers/ode/subscheck.py\": [\"checkodesol\"], \"sympy/core/symbol.py\": [\"symbols\", \"Symbol\"], \"sympy/simplify/trigsimp.py\": [\"f\"], \"sympy/functions/elementary/trigonometric.py\": [\"cos\", \"sin\"], \"sympy/simplify/fu.py\": [\"f\"], \"sympy/core/decorators.py\": [\"Symbol._func\"], \"sympy/simplify/simplify.py\": [\"f\"], \"sympy/core/expr.py\": [\"f.diff\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'sympy/solvers/ode/ode.py': ['dsolve'], 'sympy/functions/elementary/exponential.py': ['exp.exp', 'exp'], 'sympy/series/residues.py': ['residue'], 'sympy/core/cache.py': ['wrapper'], 'sympy/solvers/ode/subscheck.py': ['checkodesol'], 'sympy/core/symbol.py': ['symbols', 'Symbol'], 'sympy/simplify/trigsimp.py': ['f'], 'sympy/functions/elementary/trigonometric.py': ['cos', 'sin'], 'sympy/simplify/fu.py': ['f'], 'sympy/core/decorators.py': ['Symbol._func'], 'sympy/simplify/simplify.py': ['f'], 'sympy/core/expr.py': ['f.diff']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.17750000000000013
}