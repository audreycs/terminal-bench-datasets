{
  "repo": "pydata/xarray",
  "instance_id": "pydata__xarray-6109",
  "patch": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex c63470535b1..8638d1eb8dc 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -29,6 +29,8 @@ New Features\n \n Breaking changes\n ~~~~~~~~~~~~~~~~\n+- Rely on matplotlib's default datetime converters instead of pandas' (:issue:`6102`, :pull:`6109`).\n+  By `Jimmy Westling <https://github.com/illviljan>`_.\n - Improve repr readability when there are a large number of dimensions in datasets or dataarrays by\n   wrapping the text once the maximum display width has been exceeded. (:issue: `5546`, :pull:`5662`)\n   By `Jimmy Westling <https://github.com/illviljan>`_.\ndiff --git a/xarray/plot/utils.py b/xarray/plot/utils.py\nindex 9e7e78f4c44..3b2a133b3e5 100644\n--- a/xarray/plot/utils.py\n+++ b/xarray/plot/utils.py\n@@ -28,20 +28,9 @@\n ROBUST_PERCENTILE = 2.0\n \n \n-_registered = False\n-\n-\n-def register_pandas_datetime_converter_if_needed():\n-    # based on https://github.com/pandas-dev/pandas/pull/17710\n-    global _registered\n-    if not _registered:\n-        pd.plotting.register_matplotlib_converters()\n-        _registered = True\n-\n-\n def import_matplotlib_pyplot():\n-    \"\"\"Import pyplot as register appropriate converters.\"\"\"\n-    register_pandas_datetime_converter_if_needed()\n+    \"\"\"import pyplot\"\"\"\n+    # TODO: This function doesn't do anything (after #6109), remove it?\n     import matplotlib.pyplot as plt\n \n     return plt\n",
  "test_patch": "diff --git a/xarray/tests/test_plot.py b/xarray/tests/test_plot.py\nindex b5cc334bcd0..3088b7e109c 100644\n--- a/xarray/tests/test_plot.py\n+++ b/xarray/tests/test_plot.py\n@@ -2674,7 +2674,37 @@ def test_datetime_units(self):\n         # test that matplotlib-native datetime works:\n         fig, ax = plt.subplots()\n         ax.plot(self.darray[\"time\"], self.darray)\n-        assert isinstance(ax.xaxis.get_major_locator(), mpl.dates.AutoDateLocator)\n+\n+        # Make sure only mpl converters are used, use type() so only\n+        # mpl.dates.AutoDateLocator passes and no other subclasses:\n+        assert type(ax.xaxis.get_major_locator()) is mpl.dates.AutoDateLocator\n+\n+    def test_datetime_plot1d(self):\n+        # Test that matplotlib-native datetime works:\n+        p = self.darray.plot.line()\n+        ax = p[0].axes\n+\n+        # Make sure only mpl converters are used, use type() so only\n+        # mpl.dates.AutoDateLocator passes and no other subclasses:\n+        assert type(ax.xaxis.get_major_locator()) is mpl.dates.AutoDateLocator\n+\n+    def test_datetime_plot2d(self):\n+        # Test that matplotlib-native datetime works:\n+        da = DataArray(\n+            np.arange(3 * 4).reshape(3, 4),\n+            dims=(\"x\", \"y\"),\n+            coords={\n+                \"x\": [1, 2, 3],\n+                \"y\": [np.datetime64(f\"2000-01-{x:02d}\") for x in range(1, 5)],\n+            },\n+        )\n+\n+        p = da.plot.pcolormesh()\n+        ax = p.axes\n+\n+        # Make sure only mpl converters are used, use type() so only\n+        # mpl.dates.AutoDateLocator passes and no other subclasses:\n+        assert type(ax.xaxis.get_major_locator()) is mpl.dates.AutoDateLocator\n \n \n @pytest.mark.filterwarnings(\"ignore:setting an array element with a sequence\")\n",
  "base_commit": "bc8d7f9e708dd510672fb52e402d988e4e6ee6d6",
  "head_commit": "228e0be009ddfb383495b0c9cfa5dcd7ae1b2793",
  "created_at": 1640513687000,
  "version": "0.2",
  "duration_changes": "[{\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.0300351083278656, \"head\": 0.0267711840569973}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.0134955532848835, \"head\": 0.013636976480484009}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030788511037826538, \"head\": 0.026700202375650406}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013666592538356781, \"head\": 0.01381300762295723}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030870117247104645, \"head\": 0.026512257754802704}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.014477215707302094, \"head\": 0.013549469411373138}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030220963060855865, \"head\": 0.02714655175805092}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013346157968044281, \"head\": 0.014386024326086044}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.02964571863412857, \"head\": 0.02607007697224617}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013396292924880981, \"head\": 0.013329356908798218}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.0317067876458168, \"head\": 0.025956466794013977}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.014120176434516907, \"head\": 0.013344217091798782}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.031485140323638916, \"head\": 0.02625337615609169}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.01390749216079712, \"head\": 0.013548150658607483}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.03009156882762909, \"head\": 0.02647855505347252}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013555794954299927, \"head\": 0.014057155698537827}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.0302826389670372, \"head\": 0.025961175560951233}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013573605567216873, \"head\": 0.013340849429368973}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.029899366199970245, \"head\": 0.025592412799596786}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013565130531787872, \"head\": 0.01311618834733963}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.03015448898077011, \"head\": 0.026492353528738022}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.01368730142712593, \"head\": 0.013640593737363815}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030121780931949615, \"head\": 0.026599891483783722}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013479180634021759, \"head\": 0.013441327959299088}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030031926929950714, \"head\": 0.02678055688738823}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013440728187561035, \"head\": 0.01360289379954338}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030479058623313904, \"head\": 0.02608644962310791}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013783250004053116, \"head\": 0.013605218380689621}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030015908181667328, \"head\": 0.025864284485578537}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013392027467489243, \"head\": 0.013302039355039597}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.029658809304237366, \"head\": 0.02624215930700302}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013296745717525482, \"head\": 0.013381563127040863}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030170731246471405, \"head\": 0.02582572028040886}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.01363883912563324, \"head\": 0.013591066002845764}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.030416347086429596, \"head\": 0.02598799392580986}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.014438018202781677, \"head\": 0.013327494263648987}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.029732275754213333, \"head\": 0.026631515473127365}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013375073671340942, \"head\": 0.0134749636054039}}, {\"xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]\": {\"base\": 0.029798991978168488, \"head\": 0.0261162631213665}, \"xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x\": {\"base\": 0.013424810022115707, \"head\": 0.013468142598867416}}]",
  "efficiency_test": [
    "xarray/tests/test_plot.py::TestAxesKwargs::test_xincrease_kwarg[2-True]",
    "xarray/tests/test_plot.py::TestPlotStep::test_coord_with_interval_step_x"
  ],
  "patch_functions": "{\"xarray/plot/utils.py\": [\"import_matplotlib_pyplot\", \"register_pandas_datetime_converter_if_needed\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'xarray/plot/utils.py': ['import_matplotlib_pyplot', 'register_pandas_datetime_converter_if_needed']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"xarray/core/duck_array_ops.py\": [\"mean\"], \"xarray/plot/plot.py\": [\"step\", \"_PlotMethods.step\", \"plot\"], \"xarray/core/_reductions.py\": [\"DataArrayGroupBy.mean\"], \"xarray/core/common.py\": [\"DataArray.groupby_bins\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'xarray/core/duck_array_ops.py': ['mean'], 'xarray/plot/plot.py': ['step', '_PlotMethods.step', 'plot'], 'xarray/core/_reductions.py': ['DataArrayGroupBy.mean'], 'xarray/core/common.py': ['DataArray.groupby_bins']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.06050000000000005
}