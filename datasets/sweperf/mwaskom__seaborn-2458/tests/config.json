{
  "repo": "mwaskom/seaborn",
  "instance_id": "mwaskom__seaborn-2458",
  "patch": "diff --git a/doc/releases/v0.12.0.txt b/doc/releases/v0.12.0.txt\nindex 1e68892441..969448723d 100644\n--- a/doc/releases/v0.12.0.txt\n+++ b/doc/releases/v0.12.0.txt\n@@ -18,6 +18,8 @@ v0.12.0 (Unreleased)\n \n - |Fix| In :func:`lineplot, allowed the `dashes` keyword to set the style of a line without mapping a `style` variable (:pr:`2449`).\n \n+- |Fix| In :func:`rugplot`, fixed a bug that prevented the use of datetime data (:pr:`2458`).\n+\n - |Fix| |Enhancement| Improved integration with the matplotlib color cycle in most axes-level functions (:pr:`2449`).\n \n - Made `scipy` an optional dependency and added `pip install seaborn[all]` as a method for ensuring the availability of compatible `scipy` and `statsmodels` libraries at install time. This has a few minor implications for existing code, which are explained in the Github pull request (:pr:`2398`).\ndiff --git a/seaborn/distributions.py b/seaborn/distributions.py\nindex 8144e458b0..95ca6dcf28 100644\n--- a/seaborn/distributions.py\n+++ b/seaborn/distributions.py\n@@ -1233,7 +1233,7 @@ def plot_univariate_ecdf(self, estimate_kws, legend, **plot_kws):\n \n     def plot_rug(self, height, expand_margins, legend, **kws):\n \n-        for sub_vars, sub_data, in self.iter_data():\n+        for sub_vars, sub_data, in self.iter_data(from_comp_data=True):\n \n             ax = self._get_axes(sub_vars)\n \n",
  "test_patch": "diff --git a/seaborn/tests/test_distributions.py b/seaborn/tests/test_distributions.py\nindex 843648973a..858ac43915 100644\n--- a/seaborn/tests/test_distributions.py\n+++ b/seaborn/tests/test_distributions.py\n@@ -196,6 +196,12 @@ def test_flat_vector(self, long_df):\n         rugplot(x=long_df[\"x\"])\n         self.assert_rug_equal(*ax.collections)\n \n+    def test_datetime_data(self, long_df):\n+\n+        ax = rugplot(data=long_df[\"t\"])\n+        vals = np.stack(ax.collections[0].get_segments())[:, 0, 0]\n+        assert_array_equal(vals, mpl.dates.date2num(long_df[\"t\"]))\n+\n     def test_empty_data(self):\n \n         ax = rugplot(x=[])\n",
  "base_commit": "ba086c2096962bbffde2a8eb721b322f382f9e0e",
  "head_commit": "ab4e6dc14abbf7e7abbb40355dd2ede7e6be8306",
  "created_at": 1612045752000,
  "version": "0.12",
  "duration_changes": "[{\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.015718508511781693, \"head\": 0.02024385705590248}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.009601809084415436, \"head\": 0.0026562660932540894}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.01496889814734459, \"head\": 0.017081432044506073}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.003886766731739044, \"head\": 0.0026876144111156464}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.025797251611948013, \"head\": 0.02548113465309143}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.04407642409205437, \"head\": 0.0041681863367557526}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.019171059131622314, \"head\": 0.06946110352873802}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.003905009478330612, \"head\": 0.00786813348531723}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.016037747263908386, \"head\": 0.016127798706293106}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.003936707973480225, \"head\": 0.006695833057165146}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.11822997778654099, \"head\": 0.016202233731746674}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.0200132355093956, \"head\": 0.003948826342821121}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.06052201986312866, \"head\": 0.02367321401834488}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.007578663527965546, \"head\": 0.015038799494504929}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.01897089183330536, \"head\": 0.015791095793247223}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.003872692584991455, \"head\": 0.0078154057264328}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.02172078564763069, \"head\": 0.10630465671420097}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.0038869380950927734, \"head\": 0.09046263620257378}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.06818576529622078, \"head\": 0.01530076190829277}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.0029015056788921356, \"head\": 0.003886789083480835}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.02485749125480652, \"head\": 0.04069456458091736}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.0031798891723155975, \"head\": 0.013737499713897705}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.04185163602232933, \"head\": 0.016024522483348846}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.04413122683763504, \"head\": 0.0039145201444625854}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.022504378110170364, \"head\": 0.014753181487321854}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.003908451646566391, \"head\": 0.003913350403308868}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.04723510891199112, \"head\": 0.021761883050203323}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.0028128325939178467, \"head\": 0.06952137872576714}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.025371849536895752, \"head\": 0.03094223141670227}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.008511174470186234, \"head\": 0.06460677459836006}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.01754598692059517, \"head\": 0.013450171798467636}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.003906577825546265, \"head\": 0.0026359446346759796}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.018007252365350723, \"head\": 0.020406529307365417}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.003935568034648895, \"head\": 0.002799674868583679}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.06810879334807396, \"head\": 0.015515241771936417}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.00806732103228569, \"head\": 0.007618818432092667}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.049286454916000366, \"head\": 0.09023880213499069}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.004084039479494095, \"head\": 0.010353609919548035}}, {\"seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations\": {\"base\": 0.09495608508586884, \"head\": 0.022666338831186295}, \"seaborn/tests/test_statistics.py::TestKDE::test_gridsize\": {\"base\": 0.01843377575278282, \"head\": 0.003926131874322891}}]",
  "efficiency_test": [
    "seaborn/tests/test_categorical.py::TestViolinPlotter::test_no_observations",
    "seaborn/tests/test_statistics.py::TestKDE::test_gridsize"
  ],
  "patch_functions": "{\"seaborn/distributions.py\": [\"_DistributionPlotter.plot_rug\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'seaborn/distributions.py': ['_DistributionPlotter.plot_rug']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"seaborn/categorical.py\": [\"_ViolinPlotter.establish_variables\", \"_ViolinPlotter.estimate_densities\", \"_ViolinPlotter\"], \"seaborn/_statistics.py\": [\"KDE\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'seaborn/categorical.py': ['_ViolinPlotter.establish_variables', '_ViolinPlotter.estimate_densities', '_ViolinPlotter'], 'seaborn/_statistics.py': ['KDE']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.05200000000000004
}