{
  "repo": "mwaskom/seaborn",
  "instance_id": "mwaskom__seaborn-2389",
  "patch": "diff --git a/seaborn/matrix.py b/seaborn/matrix.py\nindex 21f06c1a47..003980389c 100644\n--- a/seaborn/matrix.py\n+++ b/seaborn/matrix.py\n@@ -38,22 +38,15 @@ def _index_to_ticklabels(index):\n \n def _convert_colors(colors):\n     \"\"\"Convert either a list of colors or nested lists of colors to RGB.\"\"\"\n-    to_rgb = mpl.colors.colorConverter.to_rgb\n-\n-    if isinstance(colors, pd.DataFrame):\n-        # Convert dataframe\n-        return pd.DataFrame({col: colors[col].map(to_rgb)\n-                            for col in colors})\n-    elif isinstance(colors, pd.Series):\n-        return colors.map(to_rgb)\n-    else:\n-        try:\n-            to_rgb(colors[0])\n-            # If this works, there is only one level of colors\n-            return list(map(to_rgb, colors))\n-        except ValueError:\n-            # If we get here, we have nested lists\n-            return [list(map(to_rgb, l)) for l in colors]\n+    to_rgb = mpl.colors.to_rgb\n+\n+    try:\n+        to_rgb(colors[0])\n+        # If this works, there is only one level of colors\n+        return list(map(to_rgb, colors))\n+    except ValueError:\n+        # If we get here, we have nested lists\n+        return [list(map(to_rgb, l)) for l in colors]\n \n \n def _matrix_mask(data, mask):\n@@ -93,7 +86,7 @@ def _matrix_mask(data, mask):\n     return mask\n \n \n-class _HeatMapper(object):\n+class _HeatMapper:\n     \"\"\"Draw a heatmap plot of a matrix with nice labels and colormaps.\"\"\"\n \n     def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,\n@@ -132,9 +125,6 @@ def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,\n         elif yticklabels is False:\n             yticklabels = []\n \n-        # Get the positions and used label for the ticks\n-        nx, ny = data.T.shape\n-\n         if not len(xticklabels):\n             self.xticks = []\n             self.xticklabels = []\n@@ -889,9 +879,9 @@ def _preprocess_colors(self, data, colors, axis):\n                 else:\n                     colors = colors.reindex(data.columns)\n \n-                # Replace na's with background color\n+                # Replace na's with white color\n                 # TODO We should set these to transparent instead\n-                colors = colors.fillna('white')\n+                colors = colors.astype(object).fillna('white')\n \n                 # Extract color values and labels from frame/series\n                 if isinstance(colors, pd.DataFrame):\n",
  "test_patch": "diff --git a/seaborn/tests/test_matrix.py b/seaborn/tests/test_matrix.py\nindex 441cc3bf9b..af2107a1cd 100644\n--- a/seaborn/tests/test_matrix.py\n+++ b/seaborn/tests/test_matrix.py\n@@ -780,6 +780,26 @@ def test_colors_input(self):\n \n         assert len(cg.fig.axes) == 6\n \n+    def test_categorical_colors_input(self):\n+        kws = self.default_kws.copy()\n+\n+        row_colors = pd.Series(self.row_colors, dtype=\"category\")\n+        col_colors = pd.Series(\n+            self.col_colors, dtype=\"category\", index=self.df_norm.columns\n+        )\n+\n+        kws['row_colors'] = row_colors\n+        kws['col_colors'] = col_colors\n+\n+        exp_row_colors = list(map(mpl.colors.to_rgb, row_colors))\n+        exp_col_colors = list(map(mpl.colors.to_rgb, col_colors))\n+\n+        cg = mat.ClusterGrid(self.df_norm, **kws)\n+        npt.assert_array_equal(cg.row_colors, exp_row_colors)\n+        npt.assert_array_equal(cg.col_colors, exp_col_colors)\n+\n+        assert len(cg.fig.axes) == 6\n+\n     def test_nested_colors_input(self):\n         kws = self.default_kws.copy()\n \n",
  "base_commit": "bcdac5411a1b71ff8d4a2fd12a937c129513e79e",
  "head_commit": "bb1708f1f038ee0fb5aae6ddca25314d8a22c772",
  "created_at": 1608320143000,
  "version": "0.12",
  "duration_changes": "[{\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.18090138584375381, \"head\": 0.09396183490753174}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.03649991378188133, \"head\": 0.08540704846382141}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.07747263833880424, \"head\": 0.07306068390607834}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.11252880096435547, \"head\": 0.09572436287999153}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.16872799396514893, \"head\": 0.13277044147253036}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.02264334261417389, \"head\": 0.10516797751188278}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.08495358377695084, \"head\": 0.1694127358496189}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.012791052460670471, \"head\": 0.011262457817792892}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.09614785388112068, \"head\": 0.06990046054124832}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.05816040188074112, \"head\": 0.09925159811973572}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.09670381993055344, \"head\": 0.09107799455523491}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.1607433743774891, \"head\": 0.015974566340446472}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.17207596078515053, \"head\": 0.08282198011875153}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.06648462638258934, \"head\": 0.09713686630129814}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.08029944077134132, \"head\": 0.16520239412784576}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.09804335981607437, \"head\": 0.024843387305736542}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.09607116132974625, \"head\": 0.19619657471776009}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.10016386955976486, \"head\": 0.014625992625951767}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.06619727611541748, \"head\": 0.09746848791837692}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.1062367707490921, \"head\": 0.10599086806178093}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.1420593559741974, \"head\": 0.09553568437695503}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.11517210677266121, \"head\": 0.11347462981939316}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.08722911402583122, \"head\": 0.08489002659916878}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.09082071110606194, \"head\": 0.11454044282436371}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.18883708864450455, \"head\": 0.07357189431786537}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.04094922915101051, \"head\": 0.09247070178389549}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.1264529749751091, \"head\": 0.06608894094824791}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.008965369313955307, \"head\": 0.13416002318263054}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.07779226824641228, \"head\": 0.0692940205335617}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.02546454593539238, \"head\": 0.10610486939549446}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.0931900218129158, \"head\": 0.11060942709445953}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.10665380209684372, \"head\": 0.07749992236495018}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.0655372142791748, \"head\": 0.10082091391086578}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.09875207394361496, \"head\": 0.07992854714393616}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.17887387424707413, \"head\": 0.06742601469159126}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.025751333683729172, \"head\": 0.1174151562154293}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.10276685282588005, \"head\": 0.07168764993548393}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.018098000437021255, \"head\": 0.10463035479187965}}, {\"seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\": {\"base\": 0.17826034128665924, \"head\": 0.10083983093500137}, \"seaborn/tests/test_statistics.py::TestKDE::test_bw_method\": {\"base\": 0.09751863032579422, \"head\": 0.02577623724937439}}]",
  "efficiency_test": [
    "seaborn/tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable",
    "seaborn/tests/test_statistics.py::TestKDE::test_bw_method"
  ],
  "patch_functions": "{\"seaborn/matrix.py\": [\"ClusterGrid._preprocess_colors\", \"_convert_colors\", \"_HeatMapper.__init__\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'seaborn/matrix.py': ['ClusterGrid._preprocess_colors', '_convert_colors', '_HeatMapper.__init__']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"seaborn/_decorators.py\": [\"inner_f\"], \"seaborn/_statistics.py\": [\"KDE\"], \"seaborn/axisgrid.py\": [\"JointGrid\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'seaborn/_decorators.py': ['inner_f'], 'seaborn/_statistics.py': ['KDE'], 'seaborn/axisgrid.py': ['JointGrid']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.035000000000000024
}