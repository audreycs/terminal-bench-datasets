{
  "repo": "sympy/sympy",
  "instance_id": "sympy__sympy-26935",
  "patch": "diff --git a/sympy/integrals/heurisch.py b/sympy/integrals/heurisch.py\nindex 5b9ce143bda9..a27e2700afd0 100644\n--- a/sympy/integrals/heurisch.py\n+++ b/sympy/integrals/heurisch.py\n@@ -504,15 +504,16 @@ def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3,\n         # optimizing the number of permutations of mapping              #\n         assert mapping[-1][0] == x # if not, find it and correct this comment\n         unnecessary_permutations = [mapping.pop(-1)]\n-        # only permute types of objects and let the ordering\n-        # of types take care of the order of replacement\n+        # permute types of objects\n         types = defaultdict(list)\n         for i in mapping:\n-            types[type(i)].append(i)\n+            e, _ = i\n+            types[type(e)].append(i)\n         mapping = [types[i] for i in types]\n         def _iter_mappings():\n             for i in permutations(mapping):\n-                yield [j for i in i for j in i]\n+                # make the expression of a given type be ordered\n+                yield [j for i in i for j in ordered(i)]\n         mappings = _iter_mappings()\n     else:\n         unnecessary_permutations = unnecessary_permutations or []\n",
  "test_patch": "diff --git a/sympy/integrals/tests/test_heurisch.py b/sympy/integrals/tests/test_heurisch.py\nindex 265186acd7fd..bcdfa2b93a92 100644\n--- a/sympy/integrals/tests/test_heurisch.py\n+++ b/sympy/integrals/tests/test_heurisch.py\n@@ -19,6 +19,8 @@\n from sympy.integrals.heurisch import components, heurisch, heurisch_wrapper\n from sympy.testing.pytest import XFAIL, slow\n from sympy.integrals.integrals import integrate\n+from sympy import S\n+\n x, y, z, nu = symbols('x,y,z,nu')\n f = Function('f')\n \n@@ -361,13 +363,13 @@ def f(x):\n \n def test_heurisch_complex_erf_issue_26338():\n     r = symbols('r', real=True)\n-    a = exp(-r**2/(2*(2 - I)**2))\n-    assert heurisch(a, r, hints=[]) is None  # None, not a wrong soln\n     a = sqrt(pi)*erf((1 + I)/2)/2\n     assert integrate(exp(-I*r**2/2), (r, 0, 1)) == a - I*a\n \n     a = exp(-x**2/(2*(2 - I)**2))\n     assert heurisch(a, x, hints=[]) is None  # None, not a wrong soln\n+    a = exp(-r**2/(2*(2 - I)**2))\n+    assert heurisch(a, r, hints=[]) is None\n     a = sqrt(pi)*erf((1 + I)/2)/2\n     assert integrate(exp(-I*x**2/2), (x, 0, 1)) == a - I*a\n \n@@ -387,3 +389,29 @@ def test_issue_15498():\n     integrand = m*m.subs(t, s)**-1*f_vec.subs(aif_eq.lhs, aif_eq.rhs).subs(t, s)\n     solution = integrate(integrand[0], (s, 0, t))\n     assert solution is not None  # does not hang and takes less than 10 s\n+\n+\n+@slow\n+def test_heurisch_issue_26930():\n+    integrand = x**Rational(4, 3)*log(x)\n+    anti = 3*x**(S(7)/3)*log(x)/7 - 9*x**(S(7)/3)/49\n+    assert heurisch(integrand, x) == anti\n+    assert integrate(integrand, x) == anti\n+    assert integrate(integrand, (x, 0, 1)) == -S(9)/49\n+\n+\n+def test_heurisch_issue_26922():\n+\n+    a, b, x = symbols(\"a, b, x\", real=True, positive=True)\n+    C = symbols(\"C\", real=True)\n+    i1 = -C*x*exp(-a*x**2 - sqrt(b)*x)\n+    i2 = C*x*exp(-a*x**2 + sqrt(b)*x)\n+    i = Integral(i1, x) + Integral(i2, x)\n+    res = (\n+        -C*exp(-a*x**2)*exp(sqrt(b)*x)/(2*a)\n+        + C*exp(-a*x**2)*exp(-sqrt(b)*x)/(2*a)\n+        + sqrt(pi)*C*sqrt(b)*exp(b/(4*a))*erf(sqrt(a)*x - sqrt(b)/(2*sqrt(a)))/(4*a**(S(3)/2))\n+        + sqrt(pi)*C*sqrt(b)*exp(b/(4*a))*erf(sqrt(a)*x + sqrt(b)/(2*sqrt(a)))/(4*a**(S(3)/2))\n+    )\n+\n+    assert i.doit(heurisch=False).expand() == res\ndiff --git a/sympy/integrals/tests/test_integrals.py b/sympy/integrals/tests/test_integrals.py\nindex 8436d6127c97..97b4dd4b30bc 100644\n--- a/sympy/integrals/tests/test_integrals.py\n+++ b/sympy/integrals/tests/test_integrals.py\n@@ -1146,8 +1146,8 @@ def test_issue_3940():\n     a, b, c, d = symbols('a:d', positive=True)\n     assert integrate(exp(-x**2 + I*c*x), x) == \\\n         -sqrt(pi)*exp(-c**2/4)*erf(I*c/2 - x)/2\n-    assert integrate(exp(a*x**2 + b*x + c), x) == \\\n-        sqrt(pi)*exp(c - b**2/(4*a))*erfi((2*a*x + b)/(2*sqrt(a)))/(2*sqrt(a))\n+    assert integrate(exp(a*x**2 + b*x + c), x).equals(\n+        sqrt(pi)*exp(c - b**2/(4*a))*erfi((2*a*x + b)/(2*sqrt(a)))/(2*sqrt(a)))\n \n     from sympy.core.function import expand_mul\n     from sympy.abc import k\n",
  "base_commit": "583993a9b99faa3f244b1863feddf4c2480ac640",
  "head_commit": "39d7c4ab3813ed99ad7dcbc4069b7a45851ff3bb",
  "created_at": 1723079905000,
  "version": "1.14",
  "duration_changes": "[{\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1872207522392273, \"head\": 1.2712255418300629}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1700980849564075, \"head\": 1.230504136532545}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1746720485389233, \"head\": 1.2369739562273026}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1827344223856926, \"head\": 1.2390726990997791}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.2035382241010666, \"head\": 1.227107748389244}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.2401292510330677, \"head\": 1.2568316981196404}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1908320635557175, \"head\": 1.2217546850442886}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.209522109478712, \"head\": 1.2408013455569744}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.197427909821272, \"head\": 1.2668375857174397}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1415341682732105, \"head\": 1.2236290723085403}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.129630073904991, \"head\": 1.2183946408331394}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1749891862273216, \"head\": 1.251250620931387}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.2004505060613155, \"head\": 1.233038380742073}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.0802251026034355, \"head\": 1.2153270579874516}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.195350259542465, \"head\": 1.241862390190363}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1879498921334743, \"head\": 1.2280415929853916}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1530789211392403, \"head\": 1.222056046128273}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.2078591100871563, \"head\": 1.2439948506653309}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.1323714032769203, \"head\": 1.2547639459371567}}, {\"sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative\": {\"base\": 2.175420206040144, \"head\": 1.246959362179041}}]",
  "efficiency_test": [
    "sympy/integrals/tests/test_integrals.py::test_mul_pow_derivative"
  ],
  "patch_functions": "{\"sympy/integrals/heurisch.py\": [\"heurisch\", \"heurisch._iter_mappings\"]}",
  "problem_statement_oracle": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\n{'sympy/integrals/heurisch.py': ['heurisch', 'heurisch._iter_mappings']}\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "test_functions": "{\"sympy/functions/elementary/exponential.py\": [\"log\"], \"sympy/core/decorators.py\": [\"Symbol._func\"], \"sympy/core/cache.py\": [\"wrapper\"], \"sympy/core/symbol.py\": [\"symbols\"], \"sympy/functions/elementary/trigonometric.py\": [\"tan\", \"cos\", \"sec\"], \"sympy/integrals/integrals.py\": [\"integrate\"], \"sympy/core/function.py\": [\"Derivative\"]}",
  "problem_statement_realistic": "Please enhance the computational efficiency and execution speed across the entire repository. The optimization efforts may target one or more objective functions, including but not limited to:\ndefaultdict(<class 'list'>, {'sympy/functions/elementary/exponential.py': ['log'], 'sympy/core/decorators.py': ['Symbol._func'], 'sympy/core/cache.py': ['wrapper'], 'sympy/core/symbol.py': ['symbols'], 'sympy/functions/elementary/trigonometric.py': ['tan', 'cos', 'sec'], 'sympy/integrals/integrals.py': ['integrate'], 'sympy/core/function.py': ['Derivative']})\nThe following conditions apply:\n1. Acceleration of at least one objective function is sufficient for success, as performance evaluations will be conducted collectively on all targeted functions.\n2. Optimization may be achieved either directly through modifications to the objective functions or indirectly by improving computationally intensive subroutines upon which they depend.\n3. Optimization efforts should prioritize maximal efficiency gains where feasible.\n4. All existing unit tests must remain unaltered to preserve functional correctness.",
  "human_performance": 0.4310000000000003
}